package main

import (
	"bytes"
	"os"
	"strconv"
	"strings"
)

const eventsGo = `package events

type ApplicationEventType uint
type WindowEventType uint

var Common = newCommonEvents()

type commonEvents struct {
$$COMMONEVENTSDECL}

func newCommonEvents() commonEvents {
	return commonEvents{
$$COMMONEVENTSVALUES	}
}

var Linux = newLinuxEvents()

type linuxEvents struct {
$$LINUXEVENTSDECL}

func newLinuxEvents() linuxEvents {
	return linuxEvents{
$$LINUXEVENTSVALUES	}
}

var Mac = newMacEvents()

type macEvents struct {
$$MACEVENTSDECL}

func newMacEvents() macEvents {
	return macEvents{
$$MACEVENTSVALUES	}
}

var Windows = newWindowsEvents()

type windowsEvents struct {
$$WINDOWSEVENTSDECL}

func newWindowsEvents() windowsEvents {
	return windowsEvents{
$$WINDOWSEVENTSVALUES	}
}

func JSEvent(event uint) string {
	return eventToJS[event]
}

var eventToJS = map[uint]string{
$$EVENTTOJS}
`

const darwinEventsH = `//go:build darwin

#ifndef _events_h
#define _events_h

extern void processApplicationEvent(unsigned int, void* data);
extern void processWindowEvent(unsigned int, unsigned int);

$$CHEADEREVENTS

#endif`

const linuxEventsH = `//go:build linux

#ifndef _events_h
#define _events_h

extern void processApplicationEvent(unsigned int, void* data);
extern void processWindowEvent(unsigned int, unsigned int);

$$CHEADEREVENTS

#endif`

const knownEvents = `package $$PACKAGE

func IsKnownEvent(name string) bool {
	_, ok := knownEvents[name]
	return ok
}

var knownEvents = map[string]struct{}{
$$EVENTNAMEMAP}
`

const eventsTS = `/*
 _	   __	  _ __
| |	 / /___ _(_) /____
| | /| / / __ ` + "`" + `/ / / ___/
| |/ |/ / /_/ / / (__  )
|__/|__/\__,_/_/_/____/
The electron alternative for Go
(c) Lea Anthony 2019-present
*/

// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Ã‚ MODIWL
// This file is automatically generated. DO NOT EDIT

export const Types = Object.freeze({
	Windows: Object.freeze({
$$WINDOWSJSEVENTS	} as const),
	Mac: Object.freeze({
$$MACJSEVENTS	} as const),
	Linux: Object.freeze({
$$LINUXJSEVENTS	} as const),
	Common: Object.freeze({
$$COMMONJSEVENTS	} as const),
} as const);

export const Windows = Types.Windows;
export const Mac = Types.Mac;
export const Linux = Types.Linux;
export const Common = Types.Common;
`

func main() {
	eventNames, err := os.ReadFile("../../pkg/events/events.txt")
	if err != nil {
		panic(err)
	}

	var linuxEventsDecl bytes.Buffer
	var linuxEventsValues bytes.Buffer
	var linuxCHeaderEvents bytes.Buffer

	var macEventsDecl bytes.Buffer
	var macEventsValues bytes.Buffer
	var macCHeaderEvents bytes.Buffer
	var windowDelegateEvents bytes.Buffer
	var applicationDelegateEvents bytes.Buffer
	var webviewDelegateEvents bytes.Buffer

	var windowsEventsDecl bytes.Buffer
	var windowsEventsValues bytes.Buffer

	var commonEventsDecl bytes.Buffer
	var commonEventsValues bytes.Buffer

	var linuxTSEvents bytes.Buffer
	var macTSEvents bytes.Buffer
	var windowsTSEvents bytes.Buffer
	var commonTSEvents bytes.Buffer

	var eventNameMap bytes.Buffer
	var eventToJS bytes.Buffer

	var id int
	//	var maxLinuxEvents int
	var maxMacEvents int
	var maxLinuxEvents int
	var line []byte
	// Loop over each line in the file
	for id, line = range bytes.Split(eventNames, []byte{'\n'}) {

		// First 1024 is reserved
		id = id + 1024

		// Skip empty lines
		if len(line) == 0 {
			continue
		}

		// split on the colon
		split := bytes.Split(line, []byte{':'})
		platform := strings.TrimSpace(string(split[0]))
		event := strings.TrimSpace(string(split[1]))
		var ignoreEvent bool
		if strings.HasSuffix(event, "!") {
			event = strings.TrimSuffix(event, "!")
			ignoreEvent = true
		}
		// Strip last byte of line if it's a "!" character
		if line[len(line)-1] == '!' {
			line = line[:len(line)-1]
		}

		// Title case the event name
		eventTitle := string(bytes.ToUpper([]byte{event[0]})) + event[1:]
		// delegate function name has a lowercase first character
		delegateEventFunction := string(bytes.ToLower([]byte{event[0]})) + event[1:]

		// Add to buffer
		switch platform {
		case "linux":
			eventType := "ApplicationEventType"
			if strings.HasPrefix(event, "Window") {
				eventType = "WindowEventType"
			}
			if strings.HasPrefix(event, "WebView") {
				eventType = "WindowEventType"
			}
			linuxEventsDecl.WriteString("\t" + eventTitle + " " + eventType + "\n")
			linuxEventsValues.WriteString("\t\t" + event + ": " + strconv.Itoa(id) + ",\n")
			linuxTSEvents.WriteString("\t\t" + event + ": \"" + strings.TrimSpace(string(line)) + "\",\n")
			eventNameMap.WriteString("\t\"" + strings.TrimSpace(string(line)) + "\": {},\n")
			eventToJS.WriteString("\t" + strconv.Itoa(id) + ": \"" + strings.TrimSpace(string(line)) + "\",\n")
			maxLinuxEvents = id
			linuxCHeaderEvents.WriteString("#define Event" + eventTitle + " " + strconv.Itoa(id) + "\n")
		case "mac":
			eventType := "ApplicationEventType"
			if strings.HasPrefix(event, "Window") {
				eventType = "WindowEventType"
			}
			if strings.HasPrefix(event, "WebView") {
				eventType = "WindowEventType"
			}
			macEventsDecl.WriteString("\t" + eventTitle + " " + eventType + "\n")
			macEventsValues.WriteString("\t\t" + event + ": " + strconv.Itoa(id) + ",\n")
			macTSEvents.WriteString("\t\t" + event + ": \"mac:" + event + "\",\n")
			macCHeaderEvents.WriteString("#define Event" + eventTitle + " " + strconv.Itoa(id) + "\n")
			eventNameMap.WriteString("\t\"" + strings.TrimSpace(string(line)) + "\": {},\n")
			eventToJS.WriteString("\t" + strconv.Itoa(id) + ": \"" + strings.TrimSpace(string(line)) + "\",\n")
			maxMacEvents = id
			if ignoreEvent {
				continue
			}
			// Check if this is a window event
			if strings.HasPrefix(event, "Window") {
				windowDelegateEvents.WriteString(`- (void)` + delegateEventFunction + `:(NSNotification *)notification {
    if( hasListeners(Event` + eventTitle + `) ) {
        processWindowEvent(self.windowId, Event` + eventTitle + `);
    }
}

`)
			}
			// Check if this is a webview event
			if strings.HasPrefix(event, "WebView") {
				webViewFunction := strings.TrimPrefix(event, "WebView")
				webViewFunction = string(bytes.ToLower([]byte{webViewFunction[0]})) + webViewFunction[1:]
				webviewDelegateEvents.WriteString(`- (void)webView:(WKWebView *)webview ` + webViewFunction + `:(WKNavigation *)navigation {
    if( hasListeners(Event` + eventTitle + `) ) {
        processWindowEvent(self.windowId, Event` + eventTitle + `);
    }
}

`)
			}
			if strings.HasPrefix(event, "Application") {
				applicationDelegateEvents.WriteString(`- (void)` + delegateEventFunction + `:(NSNotification *)notification {
    if( hasListeners(Event` + eventTitle + `) ) {
        processApplicationEvent(Event` + eventTitle + `, NULL);
    }
}

`)
			}
		case "common":
			eventType := "ApplicationEventType"
			if strings.HasPrefix(event, "Window") {
				eventType = "WindowEventType"
			}
			if strings.HasPrefix(event, "WebView") {
				eventType = "WindowEventType"
			}
			commonEventsDecl.WriteString("\t" + eventTitle + " " + eventType + "\n")
			commonEventsValues.WriteString("\t\t" + event + ": " + strconv.Itoa(id) + ",\n")
			commonTSEvents.WriteString("\t\t" + event + ": \"" + strings.TrimSpace(string(line)) + "\",\n")
			eventNameMap.WriteString("\t\"" + strings.TrimSpace(string(line)) + "\": {},\n")
			eventToJS.WriteString("\t" + strconv.Itoa(id) + ": \"" + strings.TrimSpace(string(line)) + "\",\n")
		case "windows":
			eventType := "ApplicationEventType"
			if strings.HasPrefix(event, "Window") {
				eventType = "WindowEventType"
			}
			if strings.HasPrefix(event, "WebView") {
				eventType = "WindowEventType"
			}
			windowsEventsDecl.WriteString("\t" + eventTitle + " " + eventType + "\n")
			windowsEventsValues.WriteString("\t\t" + event + ": " + strconv.Itoa(id) + ",\n")
			windowsTSEvents.WriteString("\t\t" + event + ": \"" + strings.TrimSpace(string(line)) + "\",\n")
			eventNameMap.WriteString("\t\"" + strings.TrimSpace(string(line)) + "\": {},\n")
			eventToJS.WriteString("\t" + strconv.Itoa(id) + ": \"" + strings.TrimSpace(string(line)) + "\",\n")
		}
	}

	macCHeaderEvents.WriteString("\n#define MAX_EVENTS " + strconv.Itoa(maxMacEvents+1) + "\n")
	linuxCHeaderEvents.WriteString("\n#define MAX_EVENTS " + strconv.Itoa(maxLinuxEvents+1) + "\n")

	// Save the eventsGo template substituting the values and decls
	templateToWrite := strings.ReplaceAll(eventsGo, "$$LINUXEVENTSDECL", linuxEventsDecl.String())
	templateToWrite = strings.ReplaceAll(templateToWrite, "$$LINUXEVENTSVALUES", linuxEventsValues.String())
	templateToWrite = strings.ReplaceAll(templateToWrite, "$$MACEVENTSDECL", macEventsDecl.String())
	templateToWrite = strings.ReplaceAll(templateToWrite, "$$MACEVENTSVALUES", macEventsValues.String())

	templateToWrite = strings.ReplaceAll(templateToWrite, "$$WINDOWSEVENTSDECL", windowsEventsDecl.String())
	templateToWrite = strings.ReplaceAll(templateToWrite, "$$WINDOWSEVENTSVALUES", windowsEventsValues.String())
	templateToWrite = strings.ReplaceAll(templateToWrite, "$$COMMONEVENTSDECL", commonEventsDecl.String())
	templateToWrite = strings.ReplaceAll(templateToWrite, "$$COMMONEVENTSVALUES", commonEventsValues.String())
	templateToWrite = strings.ReplaceAll(templateToWrite, "$$EVENTTOJS", eventToJS.String())
	err = os.WriteFile("../../pkg/events/events.go", []byte(templateToWrite), 0644)
	if err != nil {
		panic(err)
	}

	// Save the knownEvents template substituting the values and decls
	templateToWrite = strings.ReplaceAll(knownEvents, "$$PACKAGE", "events")
	templateToWrite = strings.ReplaceAll(templateToWrite, "$$EVENTNAMEMAP", eventNameMap.String())
	err = os.WriteFile("../../pkg/events/known_events.go", []byte(templateToWrite), 0644)
	if err != nil {
		panic(err)
	}

	templateToWrite = strings.ReplaceAll(knownEvents, "$$PACKAGE", "collect")
	templateToWrite = strings.ReplaceAll(templateToWrite, "$$EVENTNAMEMAP", eventNameMap.String())
	err = os.WriteFile("../../internal/generator/collect/known_events.go", []byte(templateToWrite), 0644)
	if err != nil {
		panic(err)
	}

	// Save the eventsTS template substituting the values and decls
	templateToWrite = strings.ReplaceAll(eventsTS, "$$MACJSEVENTS", macTSEvents.String())
	templateToWrite = strings.ReplaceAll(templateToWrite, "$$WINDOWSJSEVENTS", windowsTSEvents.String())
	templateToWrite = strings.ReplaceAll(templateToWrite, "$$LINUXJSEVENTS", linuxTSEvents.String())
	templateToWrite = strings.ReplaceAll(templateToWrite, "$$COMMONJSEVENTS", commonTSEvents.String())
	err = os.WriteFile("../../internal/runtime/desktop/@wailsio/runtime/src/event_types.ts", []byte(templateToWrite), 0644)
	if err != nil {
		panic(err)
	}

	// Save the darwinEventsH template substituting the values and decls
	templateToWrite = strings.ReplaceAll(darwinEventsH, "$$CHEADEREVENTS", macCHeaderEvents.String())
	err = os.WriteFile("../../pkg/events/events_darwin.h", []byte(templateToWrite), 0644)
	if err != nil {
		panic(err)
	}

	// Save the linuxEventsH template substituting the values and decls
	templateToWrite = strings.ReplaceAll(linuxEventsH, "$$CHEADEREVENTS", linuxCHeaderEvents.String())
	err = os.WriteFile("../../pkg/events/events_linux.h", []byte(templateToWrite), 0644)
	if err != nil {
		panic(err)
	}

	// Load the window_delegate.m file
	windowDelegate, err := os.ReadFile("../../pkg/application/webview_window_darwin.m")
	if err != nil {
		panic(err)
	}
	// iterate over the lines until we reach a line that says "// GENERATED EVENTS START"
	// then we insert the events
	// then we iterate until we reach a line that says "// GENERATED EVENTS END"
	// then we write the file
	var buffer bytes.Buffer
	var inGeneratedEvents bool
	for _, line := range bytes.Split(windowDelegate, []byte{'\n'}) {
		if bytes.Contains(line, []byte("// GENERATED EVENTS START")) {
			inGeneratedEvents = true
			buffer.WriteString("// GENERATED EVENTS START\n")
			buffer.WriteString(windowDelegateEvents.String())
			buffer.WriteString(webviewDelegateEvents.String())
			continue
		}
		if bytes.Contains(line, []byte("// GENERATED EVENTS END")) {
			inGeneratedEvents = false
			buffer.WriteString("// GENERATED EVENTS END\n")
			continue
		}
		if !inGeneratedEvents {
			if len(line) > 0 {
				buffer.Write(line)
				buffer.WriteString("\n")
			}
		}
	}
	err = os.WriteFile("../../pkg/application/webview_window_darwin.m", buffer.Bytes(), 0755)
	if err != nil {
		panic(err)
	}

	// Load the app_delegate.m file
	appDelegate, err := os.ReadFile("../../pkg/application/application_darwin_delegate.m")
	if err != nil {
		panic(err)
	}
	// iterate over the lines until we reach a line that says "// GENERATED EVENTS START"
	// then we insert the events
	// then we iterate until we reach a line that says "// GENERATED EVENTS END"
	// then we write the file
	buffer.Reset()
	for _, line := range bytes.Split(appDelegate, []byte{'\n'}) {
		if bytes.Contains(line, []byte("// GENERATED EVENTS START")) {
			inGeneratedEvents = true
			buffer.WriteString("// GENERATED EVENTS START\n")
			buffer.WriteString(applicationDelegateEvents.String())
			continue
		}
		if bytes.Contains(line, []byte("// GENERATED EVENTS END")) {
			inGeneratedEvents = false
			buffer.WriteString("// GENERATED EVENTS END\n")
			continue
		}
		if !inGeneratedEvents {
			if len(line) > 0 {
				buffer.Write(line)
				buffer.WriteString("\n")
			}
		}
	}
	err = os.WriteFile("../../pkg/application/application_darwin_delegate.m", buffer.Bytes(), 0755)
	if err != nil {
		panic(err)
	}
}
