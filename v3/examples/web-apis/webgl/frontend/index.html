<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL API Demo</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { color: #4ade80; margin-bottom: 10px; }
        .description { color: #aaa; margin-bottom: 30px; }
        .card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        h2 { font-size: 1.2rem; margin-bottom: 15px; color: #e94560; }
        button {
            background: #4ade80;
            color: #1a1a2e;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover { opacity: 0.9; }
        .status { padding: 10px; border-radius: 6px; margin-bottom: 20px; }
        .status.success { background: rgba(74, 222, 128, 0.2); color: #4ade80; }
        .status.error { background: rgba(248, 113, 113, 0.2); color: #f87171; }
        canvas {
            width: 100%;
            max-width: 600px;
            height: 400px;
            background: #000;
            border-radius: 8px;
            display: block;
            margin: 0 auto;
        }
        .controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 15px;
            justify-content: center;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-group label { color: #aaa; font-size: 0.85rem; }
        input[type="range"] { width: 120px; }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .info-item {
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 6px;
        }
        .info-item .label { color: #aaa; font-size: 0.8rem; }
        .info-item .value { color: #4ade80; font-family: monospace; }
    </style>
</head>
<body>
    <div class="container">
        <h1>WebGL API Demo</h1>
        <p class="description">
            WebGL enables rendering interactive 2D and 3D graphics in the browser
            using the GPU for hardware-accelerated rendering.
        </p>

        <div id="status" class="status">
            WebGL: <span id="supported">checking...</span>
        </div>

        <div class="card">
            <h2>3D Rotating Cube</h2>
            <div class="controls">
                <div class="control-group">
                    <label>Rotation X: <span id="rotXVal">0</span>°</label>
                    <input type="range" id="rotX" min="-180" max="180" value="0">
                </div>
                <div class="control-group">
                    <label>Rotation Y: <span id="rotYVal">0</span>°</label>
                    <input type="range" id="rotY" min="-180" max="180" value="0">
                </div>
                <div class="control-group">
                    <label>Zoom: <span id="zoomVal">5</span></label>
                    <input type="range" id="zoom" min="2" max="10" value="5" step="0.1">
                </div>
            </div>
            <div class="controls">
                <button onclick="toggleAnimation()">Toggle Animation</button>
                <button onclick="resetView()">Reset View</button>
            </div>
            <canvas id="glCanvas" width="600" height="400"></canvas>
        </div>

        <div class="card">
            <h2>WebGL Info</h2>
            <div class="info-grid" id="glInfo"></div>
        </div>
    </div>

    <script>
        let gl = null;
        let program = null;
        let animating = true;
        let rotationX = 0, rotationY = 0;
        let autoRotateX = 0, autoRotateY = 0;

        // Vertex shader
        const vsSource = `
            attribute vec4 aVertexPosition;
            attribute vec4 aVertexColor;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            varying lowp vec4 vColor;
            void main() {
                gl_Position = uProjectionMatrix * uModelViewMatrix * aVertexPosition;
                vColor = aVertexColor;
            }
        `;

        // Fragment shader
        const fsSource = `
            varying lowp vec4 vColor;
            void main() {
                gl_FragColor = vColor;
            }
        `;

        function checkWebGL() {
            const canvas = document.getElementById('glCanvas');
            gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');

            if (!gl) {
                document.getElementById('supported').textContent = 'Not supported';
                document.getElementById('status').className = 'status error';
                return false;
            }

            const webgl2 = canvas.getContext('webgl2');
            document.getElementById('supported').textContent = webgl2 ? 'WebGL 2.0' : 'WebGL 1.0';
            document.getElementById('status').className = 'status success';
            return true;
        }

        function showGLInfo() {
            if (!gl) return;
            const info = document.getElementById('glInfo');
            const renderer = gl.getParameter(gl.RENDERER);
            const vendor = gl.getParameter(gl.VENDOR);
            const version = gl.getParameter(gl.VERSION);
            const glslVersion = gl.getParameter(gl.SHADING_LANGUAGE_VERSION);
            const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
            const maxViewportDims = gl.getParameter(gl.MAX_VIEWPORT_DIMS);

            info.innerHTML = `
                <div class="info-item"><span class="label">Renderer</span><div class="value">${renderer}</div></div>
                <div class="info-item"><span class="label">Vendor</span><div class="value">${vendor}</div></div>
                <div class="info-item"><span class="label">Version</span><div class="value">${version}</div></div>
                <div class="info-item"><span class="label">GLSL Version</span><div class="value">${glslVersion}</div></div>
                <div class="info-item"><span class="label">Max Texture Size</span><div class="value">${maxTextureSize}px</div></div>
                <div class="info-item"><span class="label">Max Viewport</span><div class="value">${maxViewportDims[0]}x${maxViewportDims[1]}</div></div>
            `;
        }

        function initShaderProgram(vsSource, fsSource) {
            const vertexShader = loadShader(gl.VERTEX_SHADER, vsSource);
            const fragmentShader = loadShader(gl.FRAGMENT_SHADER, fsSource);

            program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);

            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Shader program failed:', gl.getProgramInfoLog(program));
                return null;
            }
            return program;
        }

        function loadShader(type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);

            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile error:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function initBuffers() {
            // Cube vertices
            const positions = [
                // Front face
                -1, -1,  1,  1, -1,  1,  1,  1,  1, -1,  1,  1,
                // Back face
                -1, -1, -1, -1,  1, -1,  1,  1, -1,  1, -1, -1,
                // Top face
                -1,  1, -1, -1,  1,  1,  1,  1,  1,  1,  1, -1,
                // Bottom face
                -1, -1, -1,  1, -1, -1,  1, -1,  1, -1, -1,  1,
                // Right face
                 1, -1, -1,  1,  1, -1,  1,  1,  1,  1, -1,  1,
                // Left face
                -1, -1, -1, -1, -1,  1, -1,  1,  1, -1,  1, -1,
            ];

            const colors = [
                // Front - green
                0.3, 0.85, 0.5, 1,  0.3, 0.85, 0.5, 1,  0.3, 0.85, 0.5, 1,  0.3, 0.85, 0.5, 1,
                // Back - red
                0.9, 0.27, 0.38, 1,  0.9, 0.27, 0.38, 1,  0.9, 0.27, 0.38, 1,  0.9, 0.27, 0.38, 1,
                // Top - blue
                0.38, 0.65, 0.98, 1,  0.38, 0.65, 0.98, 1,  0.38, 0.65, 0.98, 1,  0.38, 0.65, 0.98, 1,
                // Bottom - yellow
                0.98, 0.75, 0.15, 1,  0.98, 0.75, 0.15, 1,  0.98, 0.75, 0.15, 1,  0.98, 0.75, 0.15, 1,
                // Right - purple
                0.7, 0.4, 0.9, 1,  0.7, 0.4, 0.9, 1,  0.7, 0.4, 0.9, 1,  0.7, 0.4, 0.9, 1,
                // Left - cyan
                0.2, 0.8, 0.8, 1,  0.2, 0.8, 0.8, 1,  0.2, 0.8, 0.8, 1,  0.2, 0.8, 0.8, 1,
            ];

            const indices = [
                0, 1, 2,  0, 2, 3,    // front
                4, 5, 6,  4, 6, 7,    // back
                8, 9, 10, 8, 10, 11,  // top
                12, 13, 14, 12, 14, 15, // bottom
                16, 17, 18, 16, 18, 19, // right
                20, 21, 22, 20, 22, 23, // left
            ];

            const positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            const colorBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);

            const indexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            return { position: positionBuffer, color: colorBuffer, indices: indexBuffer };
        }

        function drawScene(buffers) {
            gl.clearColor(0.04, 0.04, 0.1, 1.0);
            gl.clearDepth(1.0);
            gl.enable(gl.DEPTH_TEST);
            gl.depthFunc(gl.LEQUAL);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            const zoom = parseFloat(document.getElementById('zoom').value);
            const projectionMatrix = perspectiveMatrix(45 * Math.PI / 180, 600/400, 0.1, 100.0);
            const modelViewMatrix = mat4Identity();
            mat4Translate(modelViewMatrix, 0, 0, -zoom);
            mat4RotateX(modelViewMatrix, (rotationX + autoRotateX) * Math.PI / 180);
            mat4RotateY(modelViewMatrix, (rotationY + autoRotateY) * Math.PI / 180);

            // Bind position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.position);
            const vertexPosition = gl.getAttribLocation(program, 'aVertexPosition');
            gl.vertexAttribPointer(vertexPosition, 3, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vertexPosition);

            // Bind color buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.color);
            const vertexColor = gl.getAttribLocation(program, 'aVertexColor');
            gl.vertexAttribPointer(vertexColor, 4, gl.FLOAT, false, 0, 0);
            gl.enableVertexAttribArray(vertexColor);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);
            gl.useProgram(program);

            gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uProjectionMatrix'), false, projectionMatrix);
            gl.uniformMatrix4fv(gl.getUniformLocation(program, 'uModelViewMatrix'), false, modelViewMatrix);

            gl.drawElements(gl.TRIANGLES, 36, gl.UNSIGNED_SHORT, 0);
        }

        // Simple matrix functions
        function mat4Identity() {
            return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
        }

        function mat4Translate(m, x, y, z) {
            m[12] += x; m[13] += y; m[14] += z;
        }

        function mat4RotateX(m, rad) {
            const c = Math.cos(rad), s = Math.sin(rad);
            const m4 = m[4], m5 = m[5], m6 = m[6], m7 = m[7];
            const m8 = m[8], m9 = m[9], m10 = m[10], m11 = m[11];
            m[4] = m4*c + m8*s; m[5] = m5*c + m9*s; m[6] = m6*c + m10*s; m[7] = m7*c + m11*s;
            m[8] = m8*c - m4*s; m[9] = m9*c - m5*s; m[10] = m10*c - m6*s; m[11] = m11*c - m7*s;
        }

        function mat4RotateY(m, rad) {
            const c = Math.cos(rad), s = Math.sin(rad);
            const m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3];
            const m8 = m[8], m9 = m[9], m10 = m[10], m11 = m[11];
            m[0] = m0*c - m8*s; m[1] = m1*c - m9*s; m[2] = m2*c - m10*s; m[3] = m3*c - m11*s;
            m[8] = m0*s + m8*c; m[9] = m1*s + m9*c; m[10] = m2*s + m10*c; m[11] = m3*s + m11*c;
        }

        function perspectiveMatrix(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            const nf = 1 / (near - far);
            return new Float32Array([
                f/aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far+near)*nf, -1,
                0, 0, 2*far*near*nf, 0
            ]);
        }

        // Controls
        document.getElementById('rotX').addEventListener('input', (e) => {
            rotationX = parseFloat(e.target.value);
            document.getElementById('rotXVal').textContent = rotationX;
        });

        document.getElementById('rotY').addEventListener('input', (e) => {
            rotationY = parseFloat(e.target.value);
            document.getElementById('rotYVal').textContent = rotationY;
        });

        document.getElementById('zoom').addEventListener('input', (e) => {
            document.getElementById('zoomVal').textContent = e.target.value;
        });

        function toggleAnimation() {
            animating = !animating;
        }

        function resetView() {
            rotationX = rotationY = autoRotateX = autoRotateY = 0;
            document.getElementById('rotX').value = 0;
            document.getElementById('rotY').value = 0;
            document.getElementById('zoom').value = 5;
            document.getElementById('rotXVal').textContent = '0';
            document.getElementById('rotYVal').textContent = '0';
            document.getElementById('zoomVal').textContent = '5';
        }

        // Main
        if (checkWebGL()) {
            showGLInfo();
            initShaderProgram(vsSource, fsSource);
            const buffers = initBuffers();

            function render() {
                if (animating) {
                    autoRotateX += 0.5;
                    autoRotateY += 0.7;
                }
                drawScene(buffers);
                requestAnimationFrame(render);
            }
            render();
        }
    </script>
</body>
</html>
