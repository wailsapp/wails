<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MediaRecorder API Demo</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: system-ui, sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #eee;
            min-height: 100vh;
            padding: 20px;
        }
        .container { max-width: 900px; margin: 0 auto; }
        h1 { color: #4ade80; margin-bottom: 10px; }
        .description { color: #aaa; margin-bottom: 30px; }
        .card {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
        }
        h2 { font-size: 1.2rem; margin-bottom: 15px; color: #e94560; }
        button {
            background: #4ade80;
            color: #1a1a2e;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        button:hover { opacity: 0.9; }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        button.danger { background: #f87171; }
        button.secondary { background: #60a5fa; }
        button.warning { background: #fbbf24; color: #1a1a2e; }
        .status { padding: 10px; border-radius: 6px; margin-bottom: 20px; }
        .status.success { background: rgba(74, 222, 128, 0.2); color: #4ade80; }
        .status.error { background: rgba(248, 113, 113, 0.2); color: #f87171; }
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .feature {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
        }
        .feature .name { font-weight: 600; margin-bottom: 5px; }
        .feature .supported { color: #4ade80; }
        .feature .unsupported { color: #f87171; }
        .preview-container {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        .preview-box {
            flex: 1;
            min-width: 300px;
            background: #0a0a1a;
            border-radius: 8px;
            padding: 15px;
        }
        .preview-box h3 {
            color: #aaa;
            font-size: 0.9rem;
            margin-bottom: 10px;
        }
        video, audio {
            width: 100%;
            border-radius: 6px;
            background: #000;
        }
        .recording-indicator {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            border-radius: 20px;
            background: rgba(248, 113, 113, 0.2);
            color: #f87171;
            margin-bottom: 15px;
        }
        .recording-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #f87171;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .recording-indicator.paused {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }
        .recording-indicator.paused .recording-dot {
            background: #fbbf24;
            animation: none;
        }
        .recording-indicator.stopped {
            background: rgba(74, 222, 128, 0.2);
            color: #4ade80;
        }
        .recording-indicator.stopped .recording-dot {
            background: #4ade80;
            animation: none;
        }
        .hidden { display: none !important; }
        select {
            padding: 8px 12px;
            background: #1a1a2e;
            color: #eee;
            border: 1px solid #333;
            border-radius: 4px;
            margin-right: 10px;
            margin-bottom: 10px;
        }
        .output {
            background: #0a0a1a;
            border-radius: 6px;
            padding: 15px;
            font-family: monospace;
            font-size: 0.85rem;
            max-height: 200px;
            overflow-y: auto;
        }
        .log-entry { margin-bottom: 5px; }
        .log-entry .time { color: #666; }
        .log-entry .info { color: #60a5fa; }
        .log-entry .success { color: #4ade80; }
        .log-entry .error { color: #f87171; }
        .log-entry .warn { color: #fbbf24; }
        .recordings-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 15px;
        }
        .recording-item {
            background: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        .recording-info { flex: 1; min-width: 150px; }
        .recording-info .name { font-weight: 600; color: #4ade80; }
        .recording-info .meta { font-size: 0.85rem; color: #aaa; }
        .recording-actions { display: flex; gap: 8px; flex-wrap: wrap; }
        .recording-actions button { margin: 0; padding: 6px 12px; font-size: 0.85rem; }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .stat-item {
            background: rgba(0,0,0,0.2);
            padding: 12px;
            border-radius: 6px;
            text-align: center;
        }
        .stat-value { font-size: 1.5rem; font-weight: 600; color: #4ade80; }
        .stat-label { font-size: 0.8rem; color: #aaa; margin-top: 4px; }
        .timeslice-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        .timeslice-control input {
            width: 100px;
            padding: 8px;
            background: #1a1a2e;
            color: #eee;
            border: 1px solid #333;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MediaRecorder API Demo</h1>
        <p class="description">
            The MediaRecorder API enables recording audio and video streams from MediaDevices.
            Create recordings from camera, microphone, or screen capture sources.
        </p>

        <div class="status success" id="apiStatus">
            MediaRecorder API: <span id="supported">checking...</span>
        </div>

        <div class="card">
            <h2>API Support</h2>
            <div class="feature-grid" id="features"></div>
        </div>

        <div class="card">
            <h2>Supported MIME Types</h2>
            <div class="feature-grid" id="mimeTypes"></div>
        </div>

        <div class="card">
            <h2>Audio Recording</h2>
            <div id="audioRecordingStatus" class="recording-indicator hidden">
                <div class="recording-dot"></div>
                <span id="audioStatusText">Recording...</span>
                <span id="audioTimer">00:00</span>
            </div>

            <button id="startAudioBtn" onclick="startAudioRecording()">Start Audio Recording</button>
            <button id="pauseAudioBtn" class="warning hidden" onclick="pauseAudioRecording()">Pause</button>
            <button id="resumeAudioBtn" class="secondary hidden" onclick="resumeAudioRecording()">Resume</button>
            <button id="stopAudioBtn" class="danger hidden" onclick="stopAudioRecording()">Stop</button>

            <div class="preview-box" style="margin-top: 15px;">
                <h3>Audio Playback</h3>
                <audio id="audioPlayback" controls></audio>
            </div>
        </div>

        <div class="card">
            <h2>Video Recording</h2>
            <div id="videoRecordingStatus" class="recording-indicator hidden">
                <div class="recording-dot"></div>
                <span id="videoStatusText">Recording...</span>
                <span id="videoTimer">00:00</span>
            </div>

            <div style="margin-bottom: 15px;">
                <select id="videoMimeType">
                    <option value="">Auto-select MIME type</option>
                </select>
            </div>

            <div class="timeslice-control">
                <label>Timeslice (ms):</label>
                <input type="number" id="timeslice" value="1000" min="100" step="100">
                <span style="color: #aaa; font-size: 0.85rem;">Data chunks interval</span>
            </div>

            <button id="startVideoBtn" onclick="startVideoRecording()">Start Camera Recording</button>
            <button id="startScreenBtn" class="secondary" onclick="startScreenRecording()">Start Screen Recording</button>
            <button id="pauseVideoBtn" class="warning hidden" onclick="pauseVideoRecording()">Pause</button>
            <button id="resumeVideoBtn" class="secondary hidden" onclick="resumeVideoRecording()">Resume</button>
            <button id="stopVideoBtn" class="danger hidden" onclick="stopVideoRecording()">Stop</button>

            <div class="preview-container">
                <div class="preview-box">
                    <h3>Live Preview</h3>
                    <video id="livePreview" autoplay muted playsinline></video>
                </div>
                <div class="preview-box">
                    <h3>Recording Playback</h3>
                    <video id="videoPlayback" controls playsinline></video>
                </div>
            </div>

            <div class="stats-grid" id="recordingStats">
                <div class="stat-item">
                    <div class="stat-value" id="statChunks">0</div>
                    <div class="stat-label">Data Chunks</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="statSize">0 KB</div>
                    <div class="stat-label">Total Size</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="statState">inactive</div>
                    <div class="stat-label">State</div>
                </div>
            </div>
        </div>

        <div class="card">
            <h2>Recordings</h2>
            <button class="danger" onclick="clearRecordings()">Clear All</button>
            <div class="recordings-list" id="recordingsList">
                <p style="color: #aaa;">No recordings yet. Start recording to see them here.</p>
            </div>
        </div>

        <div class="card">
            <h2>Event Log</h2>
            <button class="danger" onclick="clearLog()">Clear Log</button>
            <div class="output" id="eventLog">Events will be logged here...</div>
        </div>
    </div>

    <script>
        let audioRecorder = null;
        let videoRecorder = null;
        let audioStream = null;
        let videoStream = null;
        let audioChunks = [];
        let videoChunks = [];
        let recordings = [];
        let audioStartTime = null;
        let videoStartTime = null;
        let audioTimerInterval = null;
        let videoTimerInterval = null;

        // Check API Support
        function checkSupport() {
            const hasMediaRecorder = typeof MediaRecorder !== 'undefined';

            const supported = document.getElementById('supported');
            const apiStatus = document.getElementById('apiStatus');

            if (hasMediaRecorder) {
                supported.textContent = 'Available';
                apiStatus.className = 'status success';
            } else {
                supported.textContent = 'Not available';
                apiStatus.className = 'status error';
            }

            const features = document.getElementById('features');
            const checks = [
                { name: 'MediaRecorder', supported: hasMediaRecorder },
                { name: 'isTypeSupported()', supported: hasMediaRecorder && 'isTypeSupported' in MediaRecorder },
                { name: 'pause()', supported: hasMediaRecorder && 'pause' in MediaRecorder.prototype },
                { name: 'resume()', supported: hasMediaRecorder && 'resume' in MediaRecorder.prototype },
                { name: 'requestData()', supported: hasMediaRecorder && 'requestData' in MediaRecorder.prototype },
                { name: 'BlobEvent', supported: typeof BlobEvent !== 'undefined' },
            ];

            features.innerHTML = checks.map(c => `
                <div class="feature">
                    <div class="name">${c.name}</div>
                    <div class="${c.supported ? 'supported' : 'unsupported'}">${c.supported ? 'Supported' : 'Not supported'}</div>
                </div>
            `).join('');

            // Check MIME types
            checkMimeTypes();

            return hasMediaRecorder;
        }

        function checkMimeTypes() {
            const mimeTypesDiv = document.getElementById('mimeTypes');
            const videoSelect = document.getElementById('videoMimeType');

            const mimeTypes = [
                'video/webm',
                'video/webm;codecs=vp8',
                'video/webm;codecs=vp9',
                'video/webm;codecs=vp8,opus',
                'video/webm;codecs=vp9,opus',
                'video/mp4',
                'audio/webm',
                'audio/webm;codecs=opus',
                'audio/ogg',
                'audio/ogg;codecs=opus',
            ];

            const results = mimeTypes.map(type => ({
                name: type,
                supported: MediaRecorder.isTypeSupported(type)
            }));

            mimeTypesDiv.innerHTML = results.map(r => `
                <div class="feature">
                    <div class="name">${r.name}</div>
                    <div class="${r.supported ? 'supported' : 'unsupported'}">${r.supported ? 'Supported' : 'Not supported'}</div>
                </div>
            `).join('');

            // Populate video MIME select
            results.filter(r => r.supported && r.name.startsWith('video')).forEach(r => {
                const option = document.createElement('option');
                option.value = r.name;
                option.textContent = r.name;
                videoSelect.appendChild(option);
            });
        }

        // Logging
        function log(message, type = 'info') {
            const logDiv = document.getElementById('eventLog');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            entry.innerHTML = `<span class="time">[${time}]</span> <span class="${type}">${message}</span>`;
            logDiv.insertBefore(entry, logDiv.firstChild);
        }

        function clearLog() {
            document.getElementById('eventLog').innerHTML = '<div class="log-entry"><span class="info">Log cleared</span></div>';
        }

        // Format time
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Format size
        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        // Audio Recording
        async function startAudioRecording() {
            try {
                log('Requesting microphone access...', 'info');
                audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });

                audioRecorder = new MediaRecorder(audioStream);
                audioChunks = [];

                audioRecorder.ondataavailable = (e) => {
                    if (e.data.size > 0) {
                        audioChunks.push(e.data);
                        log(`Audio chunk received: ${formatSize(e.data.size)}`, 'info');
                    }
                };

                audioRecorder.onstart = () => {
                    log('Audio recording started', 'success');
                    audioStartTime = Date.now();
                    updateAudioUI('recording');
                    audioTimerInterval = setInterval(updateAudioTimer, 1000);
                };

                audioRecorder.onpause = () => {
                    log('Audio recording paused', 'warn');
                    updateAudioUI('paused');
                };

                audioRecorder.onresume = () => {
                    log('Audio recording resumed', 'success');
                    updateAudioUI('recording');
                };

                audioRecorder.onstop = () => {
                    log('Audio recording stopped', 'success');
                    clearInterval(audioTimerInterval);
                    updateAudioUI('stopped');

                    const blob = new Blob(audioChunks, { type: 'audio/webm' });
                    const url = URL.createObjectURL(blob);
                    document.getElementById('audioPlayback').src = url;

                    addRecording('audio', blob, url);

                    audioStream.getTracks().forEach(track => track.stop());
                };

                audioRecorder.onerror = (e) => {
                    log(`Audio recording error: ${e.error}`, 'error');
                };

                audioRecorder.start();

            } catch (e) {
                log(`Error: ${e.message}`, 'error');
            }
        }

        function pauseAudioRecording() {
            if (audioRecorder && audioRecorder.state === 'recording') {
                audioRecorder.pause();
            }
        }

        function resumeAudioRecording() {
            if (audioRecorder && audioRecorder.state === 'paused') {
                audioRecorder.resume();
            }
        }

        function stopAudioRecording() {
            if (audioRecorder && audioRecorder.state !== 'inactive') {
                audioRecorder.stop();
            }
        }

        function updateAudioTimer() {
            const elapsed = (Date.now() - audioStartTime) / 1000;
            document.getElementById('audioTimer').textContent = formatTime(elapsed);
        }

        function updateAudioUI(state) {
            const status = document.getElementById('audioRecordingStatus');
            const statusText = document.getElementById('audioStatusText');
            const startBtn = document.getElementById('startAudioBtn');
            const pauseBtn = document.getElementById('pauseAudioBtn');
            const resumeBtn = document.getElementById('resumeAudioBtn');
            const stopBtn = document.getElementById('stopAudioBtn');

            status.classList.remove('hidden', 'paused', 'stopped');

            switch (state) {
                case 'recording':
                    statusText.textContent = 'Recording...';
                    startBtn.classList.add('hidden');
                    pauseBtn.classList.remove('hidden');
                    resumeBtn.classList.add('hidden');
                    stopBtn.classList.remove('hidden');
                    break;
                case 'paused':
                    status.classList.add('paused');
                    statusText.textContent = 'Paused';
                    pauseBtn.classList.add('hidden');
                    resumeBtn.classList.remove('hidden');
                    break;
                case 'stopped':
                    status.classList.add('stopped');
                    statusText.textContent = 'Stopped';
                    setTimeout(() => {
                        status.classList.add('hidden');
                        startBtn.classList.remove('hidden');
                        pauseBtn.classList.add('hidden');
                        resumeBtn.classList.add('hidden');
                        stopBtn.classList.add('hidden');
                    }, 2000);
                    break;
            }
        }

        // Video Recording
        async function startVideoRecording() {
            try {
                log('Requesting camera and microphone access...', 'info');
                videoStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });

                document.getElementById('livePreview').srcObject = videoStream;
                startRecording(videoStream);

            } catch (e) {
                log(`Error: ${e.message}`, 'error');
            }
        }

        async function startScreenRecording() {
            try {
                log('Requesting screen capture...', 'info');
                videoStream = await navigator.mediaDevices.getDisplayMedia({
                    video: true,
                    audio: true
                });

                document.getElementById('livePreview').srcObject = videoStream;

                // Handle stream ending (user stops sharing)
                videoStream.getVideoTracks()[0].onended = () => {
                    log('Screen sharing ended', 'warn');
                    stopVideoRecording();
                };

                startRecording(videoStream);

            } catch (e) {
                log(`Error: ${e.message}`, 'error');
            }
        }

        function startRecording(stream) {
            const mimeType = document.getElementById('videoMimeType').value;
            const timeslice = parseInt(document.getElementById('timeslice').value) || 1000;

            const options = mimeType ? { mimeType } : {};

            try {
                videoRecorder = new MediaRecorder(stream, options);
            } catch (e) {
                log(`MIME type not supported, using default: ${e.message}`, 'warn');
                videoRecorder = new MediaRecorder(stream);
            }

            videoChunks = [];
            let totalSize = 0;

            videoRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    videoChunks.push(e.data);
                    totalSize += e.data.size;

                    document.getElementById('statChunks').textContent = videoChunks.length;
                    document.getElementById('statSize').textContent = formatSize(totalSize);

                    log(`Video chunk #${videoChunks.length}: ${formatSize(e.data.size)}`, 'info');
                }
            };

            videoRecorder.onstart = () => {
                log(`Video recording started (mimeType: ${videoRecorder.mimeType})`, 'success');
                videoStartTime = Date.now();
                updateVideoUI('recording');
                videoTimerInterval = setInterval(updateVideoTimer, 1000);
            };

            videoRecorder.onpause = () => {
                log('Video recording paused', 'warn');
                updateVideoUI('paused');
            };

            videoRecorder.onresume = () => {
                log('Video recording resumed', 'success');
                updateVideoUI('recording');
            };

            videoRecorder.onstop = () => {
                log('Video recording stopped', 'success');
                clearInterval(videoTimerInterval);
                updateVideoUI('stopped');
                document.getElementById('statState').textContent = 'inactive';

                const blob = new Blob(videoChunks, { type: videoRecorder.mimeType });
                const url = URL.createObjectURL(blob);
                document.getElementById('videoPlayback').src = url;

                addRecording('video', blob, url);

                document.getElementById('livePreview').srcObject = null;
                videoStream.getTracks().forEach(track => track.stop());
            };

            videoRecorder.onerror = (e) => {
                log(`Video recording error: ${e.error}`, 'error');
            };

            videoRecorder.start(timeslice);
            document.getElementById('statState').textContent = 'recording';
        }

        function pauseVideoRecording() {
            if (videoRecorder && videoRecorder.state === 'recording') {
                videoRecorder.pause();
                document.getElementById('statState').textContent = 'paused';
            }
        }

        function resumeVideoRecording() {
            if (videoRecorder && videoRecorder.state === 'paused') {
                videoRecorder.resume();
                document.getElementById('statState').textContent = 'recording';
            }
        }

        function stopVideoRecording() {
            if (videoRecorder && videoRecorder.state !== 'inactive') {
                videoRecorder.stop();
            }
        }

        function updateVideoTimer() {
            const elapsed = (Date.now() - videoStartTime) / 1000;
            document.getElementById('videoTimer').textContent = formatTime(elapsed);
        }

        function updateVideoUI(state) {
            const status = document.getElementById('videoRecordingStatus');
            const statusText = document.getElementById('videoStatusText');
            const startBtn = document.getElementById('startVideoBtn');
            const screenBtn = document.getElementById('startScreenBtn');
            const pauseBtn = document.getElementById('pauseVideoBtn');
            const resumeBtn = document.getElementById('resumeVideoBtn');
            const stopBtn = document.getElementById('stopVideoBtn');

            status.classList.remove('hidden', 'paused', 'stopped');

            switch (state) {
                case 'recording':
                    statusText.textContent = 'Recording...';
                    startBtn.classList.add('hidden');
                    screenBtn.classList.add('hidden');
                    pauseBtn.classList.remove('hidden');
                    resumeBtn.classList.add('hidden');
                    stopBtn.classList.remove('hidden');
                    break;
                case 'paused':
                    status.classList.add('paused');
                    statusText.textContent = 'Paused';
                    pauseBtn.classList.add('hidden');
                    resumeBtn.classList.remove('hidden');
                    break;
                case 'stopped':
                    status.classList.add('stopped');
                    statusText.textContent = 'Stopped';
                    setTimeout(() => {
                        status.classList.add('hidden');
                        startBtn.classList.remove('hidden');
                        screenBtn.classList.remove('hidden');
                        pauseBtn.classList.add('hidden');
                        resumeBtn.classList.add('hidden');
                        stopBtn.classList.add('hidden');
                    }, 2000);
                    break;
            }
        }

        // Recordings Management
        function addRecording(type, blob, url) {
            const recording = {
                id: Date.now(),
                type,
                blob,
                url,
                size: blob.size,
                mimeType: blob.type,
                timestamp: new Date().toLocaleString()
            };

            recordings.push(recording);
            updateRecordingsList();
            log(`Recording saved: ${type} - ${formatSize(blob.size)}`, 'success');
        }

        function updateRecordingsList() {
            const list = document.getElementById('recordingsList');

            if (recordings.length === 0) {
                list.innerHTML = '<p style="color: #aaa;">No recordings yet. Start recording to see them here.</p>';
                return;
            }

            list.innerHTML = recordings.map(r => `
                <div class="recording-item">
                    <div class="recording-info">
                        <div class="name">${r.type === 'audio' ? 'ðŸŽ¤' : 'ðŸŽ¬'} ${r.type.charAt(0).toUpperCase() + r.type.slice(1)} Recording</div>
                        <div class="meta">${r.timestamp} - ${formatSize(r.size)} - ${r.mimeType}</div>
                    </div>
                    <div class="recording-actions">
                        <button onclick="playRecording(${r.id})">Play</button>
                        <button class="secondary" onclick="downloadRecording(${r.id})">Download</button>
                        <button class="danger" onclick="deleteRecording(${r.id})">Delete</button>
                    </div>
                </div>
            `).join('');
        }

        function playRecording(id) {
            const recording = recordings.find(r => r.id === id);
            if (!recording) return;

            if (recording.type === 'audio') {
                document.getElementById('audioPlayback').src = recording.url;
                document.getElementById('audioPlayback').play();
            } else {
                document.getElementById('videoPlayback').src = recording.url;
                document.getElementById('videoPlayback').play();
            }

            log(`Playing recording: ${recording.type}`, 'info');
        }

        function downloadRecording(id) {
            const recording = recordings.find(r => r.id === id);
            if (!recording) return;

            const ext = recording.type === 'audio' ? 'webm' : 'webm';
            const filename = `${recording.type}-recording-${recording.id}.${ext}`;

            const a = document.createElement('a');
            a.href = recording.url;
            a.download = filename;
            a.click();

            log(`Downloading: ${filename}`, 'success');
        }

        function deleteRecording(id) {
            const index = recordings.findIndex(r => r.id === id);
            if (index === -1) return;

            URL.revokeObjectURL(recordings[index].url);
            recordings.splice(index, 1);
            updateRecordingsList();

            log('Recording deleted', 'warn');
        }

        function clearRecordings() {
            recordings.forEach(r => URL.revokeObjectURL(r.url));
            recordings = [];
            updateRecordingsList();
            log('All recordings cleared', 'warn');
        }

        // Initialize
        checkSupport();
    </script>
</body>
</html>
