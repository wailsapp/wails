name: V3 Changelog Validator

on:
  pull_request:
    branches: [ v3-alpha ]
    paths:
      - 'docs/src/content/docs/changelog.mdx'
  workflow_dispatch:
    inputs:
      pr_number:
        description: 'PR number to check (for manual testing)'
        required: false
        type: string

jobs:
  check-changelog:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' || github.event.inputs.pr_number
    
    permissions:
      contents: write
      pull-requests: write
      
    steps:
    - name: Checkout PR code
      uses: actions/checkout@v4
      with:
        # For PRs, checkout the PR branch with full history
        ref: ${{ github.event.pull_request.head.sha || format('refs/pull/{0}/head', github.event.inputs.pr_number) }}
        fetch-depth: 0
        # Use a token that can push to the PR branch
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Setup Go
      uses: actions/setup-go@v4
      with:
        go-version: '1.23'
        
    - name: Get PR information
      id: pr_info
      run: |
        if [ "${{ github.event_name }}" = "pull_request" ]; then
          echo "pr_number=${{ github.event.pull_request.number }}" >> $GITHUB_OUTPUT
          echo "head_ref=${{ github.event.pull_request.head.ref }}" >> $GITHUB_OUTPUT
          echo "head_sha=${{ github.event.pull_request.head.sha }}" >> $GITHUB_OUTPUT
          echo "base_ref=${{ github.event.pull_request.base.ref }}" >> $GITHUB_OUTPUT
        else
          echo "pr_number=${{ github.event.inputs.pr_number }}" >> $GITHUB_OUTPUT
          # Get PR info for manual dispatch
          PR_INFO=$(gh pr view ${{ github.event.inputs.pr_number }} --json headRefName,headRefOid,baseRefName)
          echo "head_ref=$(echo "$PR_INFO" | jq -r '.headRefName')" >> $GITHUB_OUTPUT
          echo "head_sha=$(echo "$PR_INFO" | jq -r '.headRefOid')" >> $GITHUB_OUTPUT
          echo "base_ref=$(echo "$PR_INFO" | jq -r '.baseRefName')" >> $GITHUB_OUTPUT
        fi
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Check if changelog was modified
      id: changelog_check
      run: |
        echo "ðŸ” Checking if changelog was modified in this PR..."
        
        # Get the base branch to compare against
        git fetch origin ${{ steps.pr_info.outputs.base_ref }}
        
        # Check if changelog was modified
        if git diff --name-only origin/${{ steps.pr_info.outputs.base_ref }}..HEAD | grep -q "docs/src/content/docs/changelog.mdx"; then
          echo "changelog_modified=true" >> $GITHUB_OUTPUT
          echo "âœ… Changelog was modified in this PR"
        else
          echo "changelog_modified=false" >> $GITHUB_OUTPUT
          echo "â„¹ï¸ Changelog was not modified in this PR - skipping validation"
        fi
        
    - name: Get PR diff for changelog
      id: get_diff
      if: steps.changelog_check.outputs.changelog_modified == 'true'
      run: |
        echo "ðŸ“ Getting changelog diff from this PR..."
        
        # Get the base branch to compare against
        git fetch origin ${{ steps.pr_info.outputs.base_ref }}
        
        # Get only the lines added in this PR to the changelog
        ADDED_LINES=$(git diff origin/${{ steps.pr_info.outputs.base_ref }}..HEAD docs/src/content/docs/changelog.mdx | grep "^+" | grep -v "^+++" | sed 's/^+//')
        
        echo "Lines added in this PR:"
        echo "$ADDED_LINES"
        
        # Save added lines to a file for the validation script
        echo "$ADDED_LINES" > /tmp/pr_added_lines.txt
        
        # Count added lines
        ADDED_COUNT=$(echo "$ADDED_LINES" | wc -l)
        echo "added_lines_count=$ADDED_COUNT" >> $GITHUB_OUTPUT
        
    - name: Validate and fix changelog
      id: validate_changelog
      if: steps.changelog_check.outputs.changelog_modified == 'true'
      run: |
        echo "ðŸ” Validating changelog for misplaced entries using PR diff analysis..."
        
        cd v3/internal/changelog
        
        # Create a diff-aware validation script
        cat > validate_and_fix.go << 'EOF'
        package main
        
        import (
          "bufio"
          "fmt"
          "os"
          "path/filepath"
          "strings"
        )
        
        // Simplified validator for GitHub Actions
        func main() {
          changelogPath := "../../../docs/src/content/docs/changelog.mdx"
          addedLinesPath := "/tmp/pr_added_lines.txt"
          
          // Read changelog
          content, err := readFile(changelogPath)
          if err != nil {
            fmt.Printf("ERROR: Failed to read changelog: %v\n", err)
            os.Exit(1)
          }
          
          // Read the lines added in this PR
          addedContent, err := readFile(addedLinesPath)
          if err != nil {
            fmt.Printf("ERROR: Failed to read PR added lines: %v\n", err)
            os.Exit(1)
          }
          
          addedLines := strings.Split(addedContent, "\n")
          fmt.Printf("ðŸ“ Lines added in this PR: %d\n", len(addedLines))
          
          // Parse changelog to find where added lines ended up
          lines := strings.Split(content, "\n")
          
          // Find problematic entries - only check lines that were ADDED in this PR
          var issues []Issue
          currentSection := ""
          
          for lineNum, line := range lines {
            // Track current section
            if strings.HasPrefix(line, "## ") {
              if strings.Contains(line, "[Unreleased]") {
                currentSection = "Unreleased"
              } else if strings.Contains(line, "v3.0.0-alpha") {
                // Extract version from line like "## v3.0.0-alpha.10 - 2025-07-06"
                parts := strings.Split(strings.TrimSpace(line[3:]), " - ")
                if len(parts) >= 1 {
                  currentSection = strings.TrimSpace(parts[0])
                }
              }
            }
            
            // Check if this line was added in this PR AND is in a released version
            if currentSection != "" && currentSection != "Unreleased" && 
               strings.HasPrefix(strings.TrimSpace(line), "- ") &&
               wasAddedInThisPR(line, addedLines) {
              
              issues = append(issues, Issue{
                Line:        lineNum,
                Content:     strings.TrimSpace(line),
                Section:     currentSection,
                Category:    getCurrentCategory(lines, lineNum),
              })
              fmt.Printf("ðŸš¨ MISPLACED: Line added to released version %s: %s\n", currentSection, strings.TrimSpace(line))
            }
          }
          
          if len(issues) == 0 {
            fmt.Println("VALIDATION_RESULT=success")
            fmt.Println("No misplaced changelog entries found âœ…")
            return
          }
          
          // Try to fix the issues
          fmt.Printf("Found %d potentially misplaced entries:\n", len(issues))
          for _, issue := range issues {
            fmt.Printf("  - Line %d in %s: %s\n", issue.Line+1, issue.Section, issue.Content)
          }
          
          // Attempt automatic fix
          fixed, err := attemptFix(content, issues)
          if err != nil {
            fmt.Printf("VALIDATION_RESULT=error\n")
            fmt.Printf("ERROR: Failed to fix changelog: %v\n", err)
            os.Exit(1)
          }
          
          if fixed {
            fmt.Println("VALIDATION_RESULT=fixed")
            fmt.Println("âœ… Changelog has been automatically fixed")
          } else {
            fmt.Println("VALIDATION_RESULT=cannot_fix")
            fmt.Println("âŒ Cannot automatically fix changelog issues")
            os.Exit(1)
          }
        }
        
        type Issue struct {
          Line     int
          Content  string
          Section  string
          Category string
        }
        
        func wasAddedInThisPR(line string, addedLines []string) bool {
          // Check if this exact line (trimmed) was added in this PR
          trimmedLine := strings.TrimSpace(line)
          
          for _, addedLine := range addedLines {
            trimmedAdded := strings.TrimSpace(addedLine)
            if trimmedAdded == trimmedLine {
              return true
            }
            
            // Also check if the content matches (handles whitespace differences)
            if strings.Contains(trimmedAdded, trimmedLine) && len(trimmedAdded) > 0 {
              return true
            }
          }
          
          return false
        }
        
        func getCurrentCategory(lines []string, lineNum int) string {
          // Look backwards to find the current category
          for i := lineNum - 1; i >= 0; i-- {
            line := strings.TrimSpace(lines[i])
            if strings.HasPrefix(line, "### ") {
              return strings.TrimSpace(line[4:])
            }
            if strings.HasPrefix(line, "## ") && 
               !strings.Contains(line, "[Unreleased]") && 
               !strings.Contains(line, "v3.0.0-alpha") {
              // This is a malformed category like "## Added" - should be "### Added"
              // But we'll handle it for backward compatibility
              return strings.TrimSpace(line[3:])
            }
            if strings.HasPrefix(line, "## ") && 
               (strings.Contains(line, "[Unreleased]") || strings.Contains(line, "v3.0.0-alpha")) {
              // This is a version section header, stop looking
              break
            }
          }
          return "Added" // Default fallback for new entries
        }
        
        func attemptFix(content string, issues []Issue) (bool, error) {
          lines := strings.Split(content, "\n")
          
          // Find unreleased section
          unreleasedStart := -1
          unreleasedEnd := -1
          
          for i, line := range lines {
            if strings.Contains(line, "[Unreleased]") {
              unreleasedStart = i
              // Find where unreleased section ends (next ## section)
              for j := i + 1; j < len(lines); j++ {
                if strings.HasPrefix(lines[j], "## ") && !strings.Contains(lines[j], "[Unreleased]") {
                  unreleasedEnd = j
                  break
                }
              }
              break
            }
          }
          
          if unreleasedStart == -1 {
            return false, fmt.Errorf("Could not find [Unreleased] section")
          }
          
          // Group issues by category
          issuesByCategory := make(map[string][]Issue)
          for _, issue := range issues {
            issuesByCategory[issue.Category] = append(issuesByCategory[issue.Category], issue)
          }
          
          // Remove issues from original locations (in reverse order to maintain line numbers)
          var linesToRemove []int
          for _, issue := range issues {
            linesToRemove = append(linesToRemove, issue.Line)
          }
          
          // Sort in reverse order
          for i := 0; i < len(linesToRemove); i++ {
            for j := i + 1; j < len(linesToRemove); j++ {
              if linesToRemove[i] < linesToRemove[j] {
                linesToRemove[i], linesToRemove[j] = linesToRemove[j], linesToRemove[i]
              }
            }
          }
          
          // Remove lines
          for _, lineNum := range linesToRemove {
            lines = append(lines[:lineNum], lines[lineNum+1:]...)
          }
          
          // Add entries to unreleased section
          // Find where to insert (after existing categories or create new ones)
          for category, categoryIssues := range issuesByCategory {
            // Look for existing category in unreleased section
            categoryFound := false
            insertPos := unreleasedStart + 1
            
            for i := unreleasedStart + 1; i < unreleasedEnd && i < len(lines); i++ {
              if strings.Contains(lines[i], "### " + category) || strings.Contains(lines[i], "## " + category) {
                categoryFound = true
                // Find the end of this category to append entries
                for j := i + 1; j < unreleasedEnd && j < len(lines); j++ {
                  if strings.HasPrefix(lines[j], "### ") || strings.HasPrefix(lines[j], "## ") {
                    insertPos = j
                    break
                  }
                  if j == len(lines)-1 || j == unreleasedEnd-1 {
                    insertPos = j + 1
                    break
                  }
                }
                break
              }
            }
            
            if !categoryFound {
              // Add new category at the end of unreleased section
              if unreleasedEnd > 0 {
                insertPos = unreleasedEnd
              } else {
                insertPos = unreleasedStart + 1
              }
              
              newLines := []string{
                "",
                "### " + category,
                "",
              }
              lines = append(lines[:insertPos], append(newLines, lines[insertPos:]...)...)
              insertPos += len(newLines)
              
              // Update unreleasedEnd since we added lines
              unreleasedEnd += len(newLines)
            }
            
            // Add entries to the category
            for _, issue := range categoryIssues {
              lines = append(lines[:insertPos], append([]string{issue.Content}, lines[insertPos:]...)...)
              insertPos++
              unreleasedEnd++ // Update end position
            }
          }
          
          // Write back to file
          newContent := strings.Join(lines, "\n")
          return true, writeFile("../../../docs/src/content/docs/changelog.mdx", newContent)
        }
        
        func readFile(path string) (string, error) {
          file, err := os.Open(path)
          if err != nil {
            return "", err
          }
          defer file.Close()
          
          var content strings.Builder
          scanner := bufio.NewScanner(file)
          for scanner.Scan() {
            content.WriteString(scanner.Text())
            content.WriteString("\n")
          }
          
          return content.String(), scanner.Err()
        }
        
        func writeFile(path, content string) error {
          dir := filepath.Dir(path)
          err := os.MkdirAll(dir, 0755)
          if err != nil {
            return err
          }
          
          return os.WriteFile(path, []byte(content), 0644)
        }
        EOF
        
        # Run the validation
        OUTPUT=$(go run validate_and_fix.go 2>&1)
        echo "$OUTPUT"
        
        # Extract the result
        RESULT=$(echo "$OUTPUT" | grep "VALIDATION_RESULT=" | cut -d'=' -f2)
        echo "result=$RESULT" >> $GITHUB_OUTPUT
        
        # Save the full output for later use
        echo "$OUTPUT" > /tmp/validation_output.txt
        
    - name: Commit fixes if applied
      id: commit_changes
      if: steps.validate_changelog.outputs.result == 'fixed'
      run: |
        echo "ðŸ“ Committing changelog fixes..."
        
        # Configure git
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Check if there are changes to commit
        if git diff --quiet docs/src/content/docs/changelog.mdx; then
          echo "No changes to commit"
          echo "committed=false" >> $GITHUB_OUTPUT
        else
          # Add and commit the changes
          git add docs/src/content/docs/changelog.mdx
          git commit -m "$(cat <<'EOF'
ðŸ¤– Fix changelog: move entries to Unreleased section

This automated fix was triggered by the v3-check-changelog workflow.
Misplaced entries in already-released versions have been moved to the [Unreleased] section.

Co-Authored-By: GitHub Action <action@github.com>
EOF
)"
          
          # Push the changes
          git push origin HEAD
          
          echo "committed=true" >> $GITHUB_OUTPUT
          echo "âœ… Changes committed and pushed"
        fi
        
    - name: Comment on PR - Success
      if: steps.validate_changelog.outputs.result == 'success' || steps.validate_changelog.outputs.result == 'fixed'
      uses: actions/github-script@v7
      with:
        script: |
          const result = '${{ steps.validate_changelog.outputs.result }}';
          const committed = '${{ steps.commit_changes.outputs.committed }}';
          
          let message;
          if (result === 'success') {
            message = `## âœ… Changelog Validation Passed
            
No misplaced changelog entries detected. The changelog structure looks good!`;
          } else if (result === 'fixed' && committed === 'true') {
            message = `## ðŸ”§ Changelog Updated
            
I detected some changelog entries that were added to already-released versions and automatically moved them to the \`[Unreleased]\` section.

**What was fixed:**
- Entries that belonged in the \`[Unreleased]\` section were moved from released version sections
- The changelog now follows the proper Keep a Changelog format

The changes have been committed to this PR. Please review the updated changelog.`;
          } else if (result === 'fixed' && committed === 'false') {
            message = `## âœ… Changelog Validation Passed
            
The changelog validation completed successfully. No changes were needed.`;
          }
          
          await github.rest.issues.createComment({
            issue_number: ${{ steps.pr_info.outputs.pr_number }},
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: message
          });
          
    - name: Comment on PR - Failure
      if: steps.validate_changelog.outputs.result == 'cannot_fix' || steps.validate_changelog.outputs.result == 'error'
      uses: actions/github-script@v7
      with:
        script: |
          const message = `## âŒ Invalid Changelog Entry
          
**Issue:** Changelog entries were found in already-released version sections and cannot be automatically updated.

**Problem:** You've added changelog entries to version sections that have already been released. According to the [Keep a Changelog](https://keepachangelog.com/en/1.0.0/) format, new changes should only be added to the \`[Unreleased]\` section.

**Required Action:** 
Please manually move your changelog entries from the released version sections to the \`[Unreleased]\` section and push the changes.

**How to fix:**
1. Edit \`docs/src/content/docs/changelog.mdx\`
2. Move your new entries from the released version section to the \`[Unreleased]\` section
3. Commit and push the changes

This workflow will run again after you push the fix.`;
          
          await github.rest.issues.createComment({
            issue_number: ${{ steps.pr_info.outputs.pr_number }},
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: message
          });
          
    - name: Fail workflow if cannot fix
      if: steps.validate_changelog.outputs.result == 'cannot_fix' || steps.validate_changelog.outputs.result == 'error'
      run: |
        echo "âŒ Changelog validation failed and could not be automatically fixed"
        echo "Please manually fix the changelog entries and push the changes"
        exit 1
        
    - name: Summary
      if: always() && steps.changelog_check.outputs.changelog_modified == 'true'
      run: |
        echo "## ðŸ“‹ Changelog Validation Summary" >> $GITHUB_STEP_SUMMARY
        echo "=================================" >> $GITHUB_STEP_SUMMARY
        echo "- **PR Number:** ${{ steps.pr_info.outputs.pr_number }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Result:** ${{ steps.validate_changelog.outputs.result }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Committed Changes:** ${{ steps.commit_changes.outputs.committed }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        if [ -f "/tmp/validation_output.txt" ]; then
          echo "### Validation Details" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          cat /tmp/validation_output.txt >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi