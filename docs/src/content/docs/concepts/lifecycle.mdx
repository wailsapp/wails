---
title: Application Lifecycle
description: Understanding the Wails application lifecycle from startup to shutdown
sidebar:
  order: 2
---

import { Tabs, TabItem } from "@astrojs/starlight/components";

## Understanding Application Lifecycle

Desktop applications have a lifecycle from startup to shutdown. Wails provides hooks at each stage to **initialise resources**, **clean up properly**, **handle errors gracefully**, and **manage multiple windows** effectively.

## The Lifecycle Stages

```d2
direction: down

Start: "Application Start" {
  shape: oval
  style.fill: "#10B981"
}

PreInit: "Pre-Initialisation" {
  Parse: "Parse Options" {
    shape: rectangle
  }
  Register: "Register Services" {
    shape: rectangle
  }
  Validate: "Validate Config" {
    shape: rectangle
  }
}

ServiceInit: "Service Initialisation" {
  shape: rectangle
  style.fill: "#3B82F6"
}

CreateWindows: "Create Windows" {
  shape: rectangle
}

AppStarted: "ApplicationStarted Event" {
  shape: rectangle
  style.fill: "#3B82F6"
}

EventLoop: "Event Loop" {
  Process: "Process Events" {
    shape: rectangle
  }
  Handle: "Handle Messages" {
    shape: rectangle
  }
  Update: "Update UI" {
    shape: rectangle
  }
}

QuitSignal: "Quit Signal" {
  shape: diamond
  style.fill: "#F59E0B"
}

ShouldQuit: "ShouldQuit Check" {
  shape: rectangle
  style.fill: "#3B82F6"
}

OnShutdown: "Shutdown Hooks" {
  shape: rectangle
  style.fill: "#3B82F6"
}

Cleanup: "Cleanup" {
  Close: "Close Windows" {
    shape: rectangle
  }
  Release: "Release Resources" {
    shape: rectangle
  }
}

End: "Application End" {
  shape: oval
  style.fill: "#EF4444"
}

Start -> PreInit.Parse
PreInit.Parse -> PreInit.Register
PreInit.Register -> PreInit.Validate
PreInit.Validate -> ServiceInit
ServiceInit -> CreateWindows
CreateWindows -> AppStarted
AppStarted -> EventLoop.Process
EventLoop.Process -> EventLoop.Handle
EventLoop.Handle -> EventLoop.Update
EventLoop.Update -> EventLoop.Process: "Loop"
EventLoop.Process -> QuitSignal: "User quits"
QuitSignal -> ShouldQuit: "Can cancel?"
ShouldQuit -> EventLoop.Process: "Cancelled"
ShouldQuit -> OnShutdown: "Confirmed"
OnShutdown -> Cleanup.Close
Cleanup.Close -> Cleanup.Release
Cleanup.Release -> End
```

### 1. Pre-Initialisation

Before your code runs, Wails:
1. Parses `application.Options`
2. Registers services
3. Validates configuration
4. Sets up the runtime

**You don't control this phase** - it happens automatically.

### 2. Service Initialisation

Services that implement `ServiceStartup` initialise their own resources during `app.Run()`. This is for **service-specific setup** (database connections, config loading), not for reacting to application lifecycle events:

```go
type AppService struct {
    db     *sql.DB
    config *Config
}

func (s *AppService) ServiceStartup(ctx context.Context, options application.ServiceOptions) error {
    // Initialise database
    var err error
    s.db, err = sql.Open("sqlite3", "app.db")
    if err != nil {
        return fmt.Errorf("failed to open database: %w", err)
    }

    // Load configuration
    s.config, err = loadConfig()
    if err != nil {
        return fmt.Errorf("failed to load config: %w", err)
    }

    return nil
}

app := application.New(application.Options{
    Name: "My App",
    Services: []application.Service{
        application.NewService(&AppService{}),
    },
})
```

**When it runs:** During `app.Run()`, before the event loop starts

**Use it for:**
- Database connections
- Configuration loading
- Resource initialisation

**Context:** The `context.Context` is valid as long as the application is running and is cancelled right before shutdown.

### 3. Application Lifecycle Events

To react to application lifecycle stages, use **events** — not services:

```go
// React to application start
app.Event.OnApplicationEvent(events.Common.ApplicationStarted, func(event *application.ApplicationEvent) {
    // Application is fully running - safe to show notifications, check for updates, etc.
    log.Println("Application started")
})

// React to theme changes
app.Event.OnApplicationEvent(events.Common.ThemeChanged, func(event *application.ApplicationEvent) {
    log.Println("Theme changed")
})
```

**Available common application events:**
- `events.Common.ApplicationStarted` — Application has fully started
- `events.Common.ThemeChanged` — System theme changed (light/dark)

**Platform-specific events** are also available (e.g. `events.Mac.ApplicationDidFinishLaunching`, `events.Windows.ApplicationStarted`).

**Key distinction:**
- **`ServiceStartup`** = initialise your service's resources (DB, config)
- **Application events** = react to lifecycle stages (app started, theme changed)

### 4. Window Creation

After services start up, you create windows:

```go
window := app.Window.New()
```

**What happens:**
1. Window is created (but not shown)
2. WebView is initialised
3. Frontend assets are loaded
4. Window is shown (unless `Hidden: true`)

### 5. Event Loop

The application enters the event loop:

```go
err := app.Run()  // Blocks here until quit
```

**What happens in the loop:**
- OS events processed (mouse, keyboard, window events)
- Go-to-JS messages handled
- JS-to-Go calls executed
- UI updates rendered

**This is where your application spends most of its time.**

### 6. Quit Signal

User triggers quit via:
- Closing last window (default behaviour)
- Cmd+Q / Alt+F4 / File → Quit
- Your code calling `app.Quit()`

### 7. ShouldQuit / Window Close Prevention

**Application-level quit prevention with `ShouldQuit`:**

```go
app := application.New(application.Options{
    ShouldQuit: func() bool {
        // Return false to cancel quit
        // Return true to allow quit
        if hasUnsavedChanges() {
            return false
        }
        return true
    },
})
```

**Window-level close prevention with `RegisterHook`:**

```go
window := app.Window.New()
window.RegisterHook(events.Common.WindowClosing, func(e *application.WindowEvent) {
    if hasUnsavedChanges() {
        e.Cancel() // Prevent the window from closing
    }
})
```

**Use cases:**
- Confirm quit with unsaved changes
- Prevent accidental closure
- Save state before quitting

### 8. Shutdown Hooks

There are multiple hooks for shutdown:

**`OnShutdown` (application option)** - runs first during shutdown:

```go
app := application.New(application.Options{
    OnShutdown: func() {
        // Save application state
        saveState()
    },
})
```

**`app.OnShutdown()` (runtime registration)** - add shutdown tasks dynamically:

```go
app.OnShutdown(func() {
    // Additional cleanup
    cleanup()
})
```

**`ServiceShutdown` (service interface)** - services shut down in reverse registration order:

```go
func (s *MyService) ServiceShutdown() error {
    // Close database, release resources
    return s.db.Close()
}
```

**`PostShutdown` (application option)** - runs after everything else, just before process exit:

```go
app := application.New(application.Options{
    PostShutdown: func() {
        log.Println("Application has finished shutting down")
    },
})
```

**Shutdown order:**
1. `OnShutdown` callbacks (in order added)
2. `ServiceShutdown` (reverse registration order)
3. Windows closed, system trays destroyed
4. `PostShutdown` callback

**Important:** Keep shutdown fast. OS may force-kill if too slow.

### 9. Cleanup & Exit

Wails automatically:
1. Closes all windows
2. Releases WebView resources
3. Exits the process

## Lifecycle Reference

**Application events** (react to lifecycle stages):

| Event | When | Use For |
|-------|------|---------|
| `events.Common.ApplicationStarted` | App fully running | Post-start tasks (notifications, update checks) |
| `events.Common.ThemeChanged` | System theme changed | Theme adaptation |

**Service interfaces** (resource management):

| Interface | When | Can Cancel? | Use For |
|-----------|------|-------------|---------|
| `ServiceStartup` | During `app.Run()`, before event loop | Yes (return error) | Resource initialisation |
| `ServiceShutdown` | During shutdown, reverse order | No | Resource cleanup |

**Application options** (shutdown/quit control):

| Option | When | Can Cancel? | Use For |
|--------|------|-------------|---------|
| `ShouldQuit` | App quit requested | Yes (return false) | Confirm quit |
| `OnShutdown` | After quit confirmed | No | Cleanup |
| `PostShutdown` | After shutdown complete | No | Logging, testing |

**Window hooks** (per-window lifecycle):

| Hook | When | Can Cancel? | Use For |
|------|------|-------------|---------|
| `events.Common.WindowClosing` | Window closing | Yes (`e.Cancel()`) | Prevent window close |

## Common Patterns

### Pattern 1: Database Lifecycle

```go
type DatabaseService struct {
    db *sql.DB
}

func (d *DatabaseService) ServiceStartup(ctx context.Context, options application.ServiceOptions) error {
    var err error
    d.db, err = sql.Open("sqlite3", "app.db")
    if err != nil {
        return fmt.Errorf("failed to open database: %w", err)
    }

    // Run migrations
    if err := runMigrations(d.db); err != nil {
        return fmt.Errorf("migrations failed: %w", err)
    }

    return nil
}

func (d *DatabaseService) ServiceShutdown() error {
    if d.db != nil {
        return d.db.Close()
    }
    return nil
}

app := application.New(application.Options{
    Services: []application.Service{
        application.NewService(&DatabaseService{}),
    },
})
```

### Pattern 2: Configuration Management

```go
type Config struct {
    Theme     string
    Language  string
    WindowPos Point
}

type ConfigService struct {
    config *Config
}

func (c *ConfigService) ServiceStartup(ctx context.Context, options application.ServiceOptions) error {
    var err error
    c.config, err = loadConfig()  // Load from disk
    if err != nil {
        return fmt.Errorf("failed to load config: %w", err)
    }
    return nil
}

func (c *ConfigService) ServiceShutdown() error {
    return saveConfig(c.config)  // Save to disk
}

app := application.New(application.Options{
    Services: []application.Service{
        application.NewService(&ConfigService{}),
    },
})
```

### Pattern 3: Confirm Quit with Unsaved Changes

Use `RegisterHook` with `events.Common.WindowClosing` to prevent window close, or `ShouldQuit` on the application options:

```go
// Application-level: prevent quit
app := application.New(application.Options{
    ShouldQuit: func() bool {
        if hasUnsavedChanges {
            // Return false to prevent quit
            return false
        }
        return true
    },
})

// Window-level: prevent individual window close
window := app.Window.New()
window.RegisterHook(events.Common.WindowClosing, func(e *application.WindowEvent) {
    if hasUnsavedChanges {
        e.Cancel() // Prevent window from closing
    }
})
```

### Pattern 4: Background Tasks

```go
type SyncService struct{}

func (s *SyncService) ServiceStartup(ctx context.Context, options application.ServiceOptions) error {
    // Start background task
    go func() {
        ticker := time.NewTicker(5 * time.Minute)
        defer ticker.Stop()

        for {
            select {
            case <-ticker.C:
                performBackgroundSync()
            case <-ctx.Done():
                // Context cancelled, quit
                return
            }
        }
    }()
    return nil
}

app := application.New(application.Options{
    Services: []application.Service{
        application.NewService(&SyncService{}),
    },
})
```

**Important:** Use `ctx.Done()` to know when to stop background tasks. The context is cancelled right before shutdown.

## Window Lifecycle

Each window has its own lifecycle:

```d2
direction: down

Create: "Create Window" {
  shape: oval
  style.fill: "#10B981"
}

Load: "Load Frontend" {
  shape: rectangle
}

Show: "Show Window" {
  shape: rectangle
}

Active: "Window Active" {
  Events: "Handle Events" {
    shape: rectangle
  }
}

CloseRequest: "Close Request" {
  shape: diamond
  style.fill: "#F59E0B"
}

CloseHook: "WindowClosing Hook" {
  shape: rectangle
  style.fill: "#3B82F6"
}

Destroy: "Destroy Window" {
  shape: rectangle
}

End: "Window Closed" {
  shape: oval
  style.fill: "#EF4444"
}

Create -> Load
Load -> Show
Show -> Active.Events
Active.Events -> Active.Events: "Loop"
Active.Events -> CloseRequest: "User closes"
CloseRequest -> CloseHook
CloseHook -> Active.Events: "Cancelled"
CloseHook -> Destroy: "Confirmed"
Destroy -> End
```

**Key points:**
- Each window is independent
- Closing last window quits app (by default)
- Windows can prevent their own closure

## Multi-Window Lifecycle

With multiple windows:

```go
// Create main window
mainWindow := app.Window.New()

// Create secondary window
secondaryWindow := app.Window.NewWithOptions(application.WebviewWindowOptions{
    Title: "Settings",
    Width: 400,
    Height: 600,
})

// Closing secondary window doesn't quit app
// Closing main window quits app (closes all windows)
```

**Default behaviour:**
- Closing any window closes just that window
- Closing the **last** window quits the application

**Custom behaviour:**

```go
// Prevent app quit when last window closes
app := application.New(application.Options{
    Mac: application.MacOptions{
        ApplicationShouldTerminateAfterLastWindowClosed: false,
    },
})

// Now app stays running even with no windows
// Useful for menu bar / system tray apps
```

## Error Handling During Lifecycle

### Startup Errors

Return an error from `ServiceStartup` to abort application startup. The error is propagated from `app.Run()`:

```go
func (s *MyService) ServiceStartup(ctx context.Context, options application.ServiceOptions) error {
    if err := initialise(); err != nil {
        return fmt.Errorf("initialisation failed: %w", err)
    }
    return nil
}

// In main:
err := app.Run()
if err != nil {
    log.Fatal("Failed to start:", err)
}
```

### Shutdown Errors

Errors returned from `ServiceShutdown` are logged but do not prevent shutdown:

```go
func (s *MyService) ServiceShutdown() error {
    if err := saveState(); err != nil {
        // Error will be logged by Wails
        return fmt.Errorf("failed to save state: %w", err)
    }
    return nil
}
```

**Important:** Shutdown hooks run during quit - don't show dialogs or try to cancel.

## Platform Differences

### macOS

- **Application menu** persists even with no windows
- **Cmd+Q** always quits (can't be prevented)
- **Dock icon** remains unless hidden

### Windows

- **No application menu** without a window
- **Alt+F4** closes window (can be prevented)
- **System tray** can keep app running

### Linux

- **Behaviour varies** by desktop environment
- **Generally similar to Windows**

## Debugging Lifecycle Issues

### Problem: Resources Not Cleaned Up

**Symptom:** Database connections left open, files not closed

**Solution:** Implement `ServiceShutdown` on your services:

```go
func (s *MyService) ServiceShutdown() error {
    log.Println("Cleaning up...")
    // Your cleanup code
    return s.db.Close()
}
```

### Problem: Application Won't Quit

**Symptom:** App hangs when trying to quit

**Causes:**
1. `ShouldQuit` returning `false`
2. Window close hook cancelling close events
3. Shutdown tasks taking too long
4. Background goroutines not stopping

**Solution:**

```go
// 1. Check ShouldQuit logic
app := application.New(application.Options{
    ShouldQuit: func() bool {
        log.Println("ShouldQuit called")
        return true  // Allow quit
    },
})

// 2. Keep shutdown fast
app.OnShutdown(func() {
    log.Println("Shutdown started")
    // Fast cleanup only
    log.Println("Shutdown finished")
})

// 3. Stop background tasks using context
func (s *MyService) ServiceStartup(ctx context.Context, options application.ServiceOptions) error {
    go func() {
        for {
            select {
            case <-ctx.Done():
                log.Println("Background task stopped")
                return
            default:
                // Work
            }
        }
    }()
    return nil
}
```

### Problem: Initialisation Fails Silently

**Symptom:** App starts but doesn't work correctly

**Solution:** Return errors from `ServiceStartup` to abort startup:

```go
func (s *MyService) ServiceStartup(ctx context.Context, options application.ServiceOptions) error {
    if err := initialise(); err != nil {
        return fmt.Errorf("initialisation failed: %w", err)
    }
    return nil
}

// In main - app.Run() returns the error:
if err := app.Run(); err != nil {
    log.Fatal("Failed to start:", err)
}
```

## Best Practices

### ✅ Do

- **Use `ServiceStartup` for resource init** - Database, config, connections
- **Use application events for lifecycle** - `events.Common.ApplicationStarted` for post-start tasks
- **Clean up in `ServiceShutdown`** - Close connections, save state
- **Keep shutdown fast** - &lt;1 second
- **Use context for cancellation** - Stop background tasks
- **Handle errors gracefully** - Return errors from ServiceStartup
- **Test quit scenarios** - Unsaved changes, background tasks

### ❌ Don't

- **Don't use `ServiceStartup` for lifecycle hooks** - Use application events instead
- **Don't block ServiceStartup** - Keep it fast (&lt;2 seconds)
- **Don't show dialogs during shutdown** - App is quitting
- **Don't ignore errors** - Log or return them
- **Don't leak resources** - Always clean up in ServiceShutdown
- **Don't forget background tasks** - Stop them using ctx.Done()

## Next Steps

**Go-Frontend Bridge** - Understand how Go and JavaScript communicate  
[Learn More →](/concepts/bridge)

**Build System** - Learn how Wails builds your application  
[Learn More →](/concepts/build-system)

**Events System** - Use events for communication between components  
[Learn More →](/features/events/system)

**Window Management** - Create and manage multiple windows  
[Learn More →](/features/windows/basics)

---

**Questions about lifecycle?** Ask in [Discord](https://discord.gg/JDdSxwjhGf) or check the [examples](https://github.com/wailsapp/wails/tree/v3-alpha/v3/examples).
