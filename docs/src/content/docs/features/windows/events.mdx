---
title: Window Events
description: Handle window lifecycle and state change events
sidebar:
  order: 5
---

import { Tabs, TabItem } from "@astrojs/starlight/components";

## Window Events

Wails provides **comprehensive event handling** for window lifecycle and state changes: creation, focus/blur, resize/move, minimise/maximise, and close events. Register callbacks, handle events, and coordinate between windows with simple, consistent APIs.

## Event Registration Methods

Wails provides two methods for handling window events:

- **`OnWindowEvent()`** - Listen to window events (cannot prevent them)
- **`RegisterHook()`** - Hook into window events (can prevent them by calling `event.Cancel()`)

Both methods return a cleanup function that can be called to remove the listener/hook.

### OnWindowEvent

Registers a callback for window events. The callback receives a `*WindowEvent` argument.

```go
import "github.com/wailsapp/wails/v3/pkg/events"

// Listen for window focus
cancel := window.OnWindowEvent(events.Common.WindowFocus, func(e *application.WindowEvent) {
    fmt.Println("Window gained focus")
})

// Later, remove the listener
cancel()
```

### RegisterHook

Registers a hook that runs **before** listeners and can prevent the event by calling `event.Cancel()`.

```go
import "github.com/wailsapp/wails/v3/pkg/events"

// Prevent window from closing
cancel := window.RegisterHook(events.Common.WindowClosing, func(e *application.WindowEvent) {
    if hasUnsavedChanges() {
        e.Cancel() // Prevent the close
    }
})
```

## Lifecycle Events

### OnCreate

Called when a window is created. Register via the window manager:

```go
app.Window.OnCreate(func(window application.Window) {
    fmt.Printf("Window created: %s\n", window.Name())

    // Configure all new windows
    window.SetMinSize(400, 300)
})
```

**Use cases:**
- Configure all windows consistently
- Register event handlers
- Track window creation
- Initialise window-specific resources

### WindowClosing

Fired when the user attempts to close a window. Use `RegisterHook` to cancel the close.

```go
// Prevent close with a hook
window.RegisterHook(events.Common.WindowClosing, func(e *application.WindowEvent) {
    if hasUnsavedChanges() {
        e.Cancel() // Prevent the window from closing
    }
})

// React to close with a listener (cannot cancel)
window.OnWindowEvent(events.Common.WindowClosing, func(e *application.WindowEvent) {
    fmt.Println("Window is closing, cleaning up...")
    cleanup()
})
```

**Important:**
- Hooks run before listeners and can call `e.Cancel()` to prevent the close
- Listeners cannot cancel the event

## Focus Events

### WindowFocus / WindowLostFocus

```go
window.OnWindowEvent(events.Common.WindowFocus, func(e *application.WindowEvent) {
    fmt.Println("Window gained focus")
    updateTitleBar(true)
})

window.OnWindowEvent(events.Common.WindowLostFocus, func(e *application.WindowEvent) {
    fmt.Println("Window lost focus")
    updateTitleBar(false)
})
```

**Use cases:**
- Update UI appearance
- Refresh data on focus
- Pause operations on blur
- Coordinate with other windows

**Example: Focus-aware UI:**

```go
window.OnWindowEvent(events.Common.WindowFocus, func(e *application.WindowEvent) {
    window.EmitEvent("update-theme", "active")
})

window.OnWindowEvent(events.Common.WindowLostFocus, func(e *application.WindowEvent) {
    window.EmitEvent("update-theme", "inactive")
})
```

## State Change Events

### WindowMinimise / WindowUnMinimise

```go
window.OnWindowEvent(events.Common.WindowMinimise, func(e *application.WindowEvent) {
    fmt.Println("Window minimised")
    pauseRendering()
})

window.OnWindowEvent(events.Common.WindowUnMinimise, func(e *application.WindowEvent) {
    fmt.Println("Window restored from minimised")
    resumeRendering()
})
```

### WindowMaximise / WindowUnMaximise

```go
window.OnWindowEvent(events.Common.WindowMaximise, func(e *application.WindowEvent) {
    fmt.Println("Window maximised")
    window.EmitEvent("layout-mode", "maximised")
})

window.OnWindowEvent(events.Common.WindowUnMaximise, func(e *application.WindowEvent) {
    fmt.Println("Window restored from maximised")
    window.EmitEvent("layout-mode", "normal")
})
```

### WindowFullscreen / WindowUnFullscreen

```go
window.OnWindowEvent(events.Common.WindowFullscreen, func(e *application.WindowEvent) {
    fmt.Println("Window entered fullscreen")
    window.EmitEvent("chrome-visibility", false)
})

window.OnWindowEvent(events.Common.WindowUnFullscreen, func(e *application.WindowEvent) {
    fmt.Println("Window exited fullscreen")
    window.EmitEvent("chrome-visibility", true)
})
```

## Position and Size Events

### WindowDidMove

```go
window.OnWindowEvent(events.Common.WindowDidMove, func(e *application.WindowEvent) {
    x, y := window.Position()
    fmt.Printf("Window moved to: %d, %d\n", x, y)
    saveWindowPosition(x, y)
})
```

### WindowDidResize

```go
window.OnWindowEvent(events.Common.WindowDidResize, func(e *application.WindowEvent) {
    width, height := window.Size()
    fmt.Printf("Window resized to: %dx%d\n", width, height)
    saveWindowSize(width, height)
})
```

**Note:** The move and resize event callbacks receive a `*WindowEvent` argument. To get the new position or size, call `window.Position()` or `window.Size()` inside the callback.

## Common Window Events Reference

| Event | Description |
|-------|-------------|
| `events.Common.WindowClosing` | Window is about to close |
| `events.Common.WindowFocus` | Window gained focus |
| `events.Common.WindowLostFocus` | Window lost focus |
| `events.Common.WindowDidMove` | Window moved |
| `events.Common.WindowDidResize` | Window resized |
| `events.Common.WindowMinimise` | Window minimised |
| `events.Common.WindowUnMinimise` | Window restored from minimised |
| `events.Common.WindowMaximise` | Window maximised |
| `events.Common.WindowUnMaximise` | Window restored from maximised |
| `events.Common.WindowFullscreen` | Window entered fullscreen |
| `events.Common.WindowUnFullscreen` | Window exited fullscreen |
| `events.Common.WindowFilesDropped` | Files were dropped onto the window |

## Complete Example

Here's a production-ready window with full event handling:

```go
package main

import (
    "encoding/json"
    "fmt"
    "os"

    "github.com/wailsapp/wails/v3/pkg/application"
    "github.com/wailsapp/wails/v3/pkg/events"
)

type WindowState struct {
    X          int  `json:"x"`
    Y          int  `json:"y"`
    Width      int  `json:"width"`
    Height     int  `json:"height"`
    Maximised  bool `json:"maximised"`
    Fullscreen bool `json:"fullscreen"`
}

type ManagedWindow struct {
    app     *application.App
    window  *application.WebviewWindow
    state   WindowState
    dirty   bool
}

func main() {
    app := application.New(application.Options{
        Name: "Event Demo",
    })

    mw := &ManagedWindow{app: app}
    mw.CreateWindow()
    mw.LoadState()
    mw.SetupEventHandlers()

    app.Run()
}

func (mw *ManagedWindow) CreateWindow() {
    mw.window = mw.app.Window.NewWithOptions(application.WebviewWindowOptions{
        Name:   "main",
        Title:  "Event Demo",
        Width:  800,
        Height: 600,
    })
}

func (mw *ManagedWindow) SetupEventHandlers() {
    // Focus events
    mw.window.OnWindowEvent(events.Common.WindowFocus, func(e *application.WindowEvent) {
        fmt.Println("Window focused")
        mw.window.EmitEvent("focus-state", true)
    })

    mw.window.OnWindowEvent(events.Common.WindowLostFocus, func(e *application.WindowEvent) {
        fmt.Println("Window blurred")
        mw.window.EmitEvent("focus-state", false)
    })

    // State change events
    mw.window.OnWindowEvent(events.Common.WindowMinimise, func(e *application.WindowEvent) {
        fmt.Println("Window minimised")
        mw.SaveState()
    })

    mw.window.OnWindowEvent(events.Common.WindowMaximise, func(e *application.WindowEvent) {
        fmt.Println("Window maximised")
        mw.state.Maximised = true
        mw.dirty = true
    })

    mw.window.OnWindowEvent(events.Common.WindowUnMaximise, func(e *application.WindowEvent) {
        fmt.Println("Window restored from maximised")
        mw.state.Maximised = false
        mw.dirty = true
    })

    mw.window.OnWindowEvent(events.Common.WindowFullscreen, func(e *application.WindowEvent) {
        fmt.Println("Window fullscreen")
        mw.state.Fullscreen = true
        mw.dirty = true
    })

    mw.window.OnWindowEvent(events.Common.WindowUnFullscreen, func(e *application.WindowEvent) {
        fmt.Println("Window exited fullscreen")
        mw.state.Fullscreen = false
        mw.dirty = true
    })

    // Position and size events
    mw.window.OnWindowEvent(events.Common.WindowDidMove, func(e *application.WindowEvent) {
        mw.state.X, mw.state.Y = mw.window.Position()
        mw.dirty = true
    })

    mw.window.OnWindowEvent(events.Common.WindowDidResize, func(e *application.WindowEvent) {
        mw.state.Width, mw.state.Height = mw.window.Size()
        mw.dirty = true
    })

    // Lifecycle: save state on close
    mw.window.OnWindowEvent(events.Common.WindowClosing, func(e *application.WindowEvent) {
        if mw.dirty {
            mw.SaveState()
        }
        fmt.Println("Window closing")
    })
}

func (mw *ManagedWindow) LoadState() {
    data, err := os.ReadFile("window-state.json")
    if err != nil {
        return
    }

    if err := json.Unmarshal(data, &mw.state); err != nil {
        return
    }

    // Restore window state
    mw.window.SetPosition(mw.state.X, mw.state.Y)
    mw.window.SetSize(mw.state.Width, mw.state.Height)

    if mw.state.Maximised {
        mw.window.Maximise()
    }

    if mw.state.Fullscreen {
        mw.window.Fullscreen()
    }
}

func (mw *ManagedWindow) SaveState() {
    data, err := json.Marshal(mw.state)
    if err != nil {
        return
    }

    os.WriteFile("window-state.json", data, 0644)
    mw.dirty = false

    fmt.Println("Window state saved")
}
```

## Event Coordination

### Cross-Window Events

Coordinate between multiple windows:

```go
// In main window
window.OnWindowEvent(events.Common.WindowFocus, func(e *application.WindowEvent) {
    // Notify all windows via the application event system
    app.Event.Emit("main-window-focused", nil)
})

// In other windows
app.Event.On("main-window-focused", func(event *application.CustomEvent) {
    updateRelativeToMain()
})
```

### Event Chains

Chain events together:

```go
window.OnWindowEvent(events.Common.WindowMaximise, func(e *application.WindowEvent) {
    // Save state
    saveWindowState()

    // Update layout
    window.EmitEvent("layout-changed", "maximised")

    // Notify other windows
    app.Event.Emit("window-maximised", window.Name())
})
```

### Debounced Events

Debounce frequent events:

```go
var resizeTimer *time.Timer

window.OnWindowEvent(events.Common.WindowDidResize, func(e *application.WindowEvent) {
    if resizeTimer != nil {
        resizeTimer.Stop()
    }

    resizeTimer = time.AfterFunc(500*time.Millisecond, func() {
        width, height := window.Size()
        saveWindowSize(width, height)
    })
})
```

## Best Practices

### Do

- **Save state on close** - Restore window position/size
- **Cleanup on close** - Release resources via `OnWindowEvent(events.Common.WindowClosing, ...)`
- **Debounce frequent events** - Resize, move
- **Handle focus changes** - Update UI appropriately
- **Coordinate windows** - Use events for communication
- **Test all events** - Ensure handlers work correctly

### Don't

- **Don't block event handlers** - Keep them fast
- **Don't forget cleanup** - Memory leaks
- **Don't ignore errors** - Log or handle them
- **Don't save on every event** - Debounce first
- **Don't create circular events** - Infinite loops
- **Don't forget platform differences** - Test thoroughly

## Troubleshooting

### Close Not Being Prevented

**Cause:** Using `OnWindowEvent` instead of `RegisterHook`

**Solution:**

```go
// OnWindowEvent cannot cancel events
// Use RegisterHook instead:
window.RegisterHook(events.Common.WindowClosing, func(e *application.WindowEvent) {
    e.Cancel() // This prevents the close
})
```

### Events Not Firing

**Cause:** Handler registered after event occurred

**Solution:**

```go
// Register handlers immediately after creation
window := app.Window.New()
window.OnWindowEvent(events.Common.WindowClosing, func(e *application.WindowEvent) {
    // handle close
})
```

### Memory Leaks

**Cause:** Not calling the cleanup function returned by event registration

**Solution:**

```go
// Store and call the cancel function when done
cancel := window.OnWindowEvent(events.Common.WindowFocus, func(e *application.WindowEvent) {
    // handle focus
})

// Later, remove the listener
cancel()
```

## Next Steps

**Window Basics** - Learn the fundamentals of window management
[Learn More ->](/features/windows/basics)

**Multiple Windows** - Patterns for multi-window applications
[Learn More ->](/features/windows/multiple)

**Events System** - Deep dive into the event system
[Learn More ->](/features/events/system)

**Application Lifecycle** - Understand the application lifecycle
[Learn More ->](/concepts/lifecycle)

---

**Questions?** Ask in [Discord](https://discord.gg/JDdSxwjhGf) or check the [examples](https://github.com/wailsapp/wails/tree/v3-alpha/v3/examples).
