---
title: Advanced Binding
description: Advanced binding techniques including directives, code injection, and custom IDs
sidebar:
  order: 3
---

import { FileTree } from "@astrojs/starlight/components";

This guide covers advanced techniques for customizing and optimizing the binding generation process in Wails v3.

## Customizing Generated Code with Directives

### Injecting Custom Code

The `//wails:inject` directive allows you to inject custom JavaScript/TypeScript code into the generated bindings:

```go
//wails:inject console.log("Hello from Wails!");
type MyService struct {}

func (s *MyService) Greet(name string) string {
    return "Hello, " + name
}
```

This will inject the specified code into the generated JavaScript/TypeScript file for the `MyService` service.

You can also use conditional injection to target specific output formats:

```go
//wails:inject j*:console.log("Hello JS!");  // JavaScript only
//wails:inject t*:console.log("Hello TS!");  // TypeScript only
```

### Including Additional Files

The `//wails:include` directive allows you to include additional files with the generated bindings:

```go
//wails:include js/*.js
package mypackage
```

This directive is typically used in package documentation comments to include additional JavaScript/TypeScript files with the generated bindings.

### Marking Internal Types and Methods

The `//wails:internal` directive marks a type or method as module-private. The method or type **is still generated** in the JavaScript/TypeScript bindings, but it is **not re-exported** from the package's index file. This means it is accessible within the generated service module but not part of the public API.

This is primarily useful in combination with `//wails:inject` to create custom JavaScript wrappers around internal methods (see [The Internal + Inject Pattern](#the-internal--inject-pattern) below).

```go
//wails:internal
type InternalModel struct {
    Field string
}

//wails:internal
func (s *MyService) InternalMethod() {}
```

### Ignoring Methods

The `//wails:ignore` directive **completely excludes** a method from binding generation. No JavaScript/TypeScript code is generated for the method at all - it exists only in Go:

```go
//wails:ignore
func (s *MyService) IgnoredMethod() {}
```

Use `//wails:ignore` when a method should have no frontend presence whatsoever. Use `//wails:internal` when the method needs to be available in JS but should not be part of the public API (e.g., to be wrapped by injected code).

### Custom Method IDs

The `//wails:id` directive specifies a custom ID for a method, overriding the default hash-based ID:

```go
//wails:id 42
func (s *MyService) CustomIDMethod() {}
```

This can be useful for maintaining compatibility when refactoring code.

## Working with Complex Types

### Nested Structs

The binding generator handles nested structs automatically:

```go
type Address struct {
    Street string
    City   string
    State  string
    Zip    string
}

type Person struct {
    Name    string
    Address Address
}

func (s *MyService) GetPerson() Person {
    return Person{
        Name: "John Doe",
        Address: Address{
            Street: "123 Main St",
            City:   "Anytown",
            State:  "CA",
            Zip:    "12345",
        },
    }
}
```

The generated JavaScript/TypeScript code will include classes for both `Person` and `Address`.

### Maps and Slices

Maps and slices are also handled automatically:

```go
type Person struct {
    Name       string
    Attributes map[string]string
    Friends    []string
}

func (s *MyService) GetPerson() Person {
    return Person{
        Name: "John Doe",
        Attributes: map[string]string{
            "hair": "brown",
            "eyes": "blue",
        },
        Friends: []string{"Jane", "Bob", "Alice"},
    }
}
```

In JavaScript, maps are represented as objects and slices as arrays. In TypeScript, maps are represented as `Record<K, V>` and slices as `T[]`.

### Generic Types

The binding generator supports generic types:

```go
type Result[T any] struct {
    Data  T
    Error string
}

func (s *MyService) GetResult() Result[string] {
    return Result[string]{
        Data:  "Hello, World!",
        Error: "",
    }
}
```

The generated TypeScript code will include a generic class for `Result`:

```typescript
export class Result<T> {
    "Data": T;
    "Error": string;

    constructor(source: Partial<Result<T>> = {}) {
        if (!("Data" in source)) {
            this["Data"] = null as any;
        }
        if (!("Error" in source)) {
            this["Error"] = "";
        }

        Object.assign(this, source);
    }

    static createFrom<T>(source: string | object = {}): Result<T> {
        let parsedSource = typeof source === "string" ? JSON.parse(source) : source;
        return new Result<T>(parsedSource as Partial<Result<T>>);
    }
}
```

### Interfaces

The binding generator can generate TypeScript interfaces instead of classes using the `-i` flag:

```bash
wails3 generate bindings -ts -i
```

This will generate TypeScript interfaces for all models:

```typescript
export interface Person {
    Name: string;
    Attributes: Record<string, string>;
    Friends: string[];
}
```

## Optimizing Binding Generation

### Using Names Instead of IDs

By default, the binding generator uses hash-based IDs for method calls. You can use the `-names` flag to use names instead:

```bash
wails3 generate bindings -names
```

This will generate code that uses fully qualified method names instead of IDs:

```javascript
export function Greet(name) {
    return $Call.ByName("main.MyService.Greet", name);
}
```

This can make the generated code more readable and easier to debug, but it may be slightly less efficient.

### Bundling the Runtime

By default, the generated code imports the Wails runtime from the `@wailsio/runtime` npm package. You can use the `-b` flag to bundle the runtime with the generated code:

```bash
wails3 generate bindings -b
```

This will include the runtime code directly in the generated files, eliminating the need for the npm package.

### Disabling Index Files

If you don't need the index files, you can use the `-noindex` flag to disable their generation:

```bash
wails3 generate bindings -noindex
```

This can be useful if you prefer to import services and models directly from their respective files.

## Real-World Examples

### Authentication Service

Here's an example of an authentication service with custom directives:

```go
package auth

//wails:inject console.log("Auth service initialized");
type AuthService struct {
    // Private fields
    users map[string]User
}

type User struct {
    Username string
    Email    string
    Role     string
}

type LoginRequest struct {
    Username string
    Password string
}

type LoginResponse struct {
    Success bool
    User    User
    Token   string
    Error   string
}

// Login authenticates a user
func (s *AuthService) Login(req LoginRequest) LoginResponse {
    // Implementation...
}

// GetCurrentUser returns the current user
func (s *AuthService) GetCurrentUser() User {
    // Implementation...
}

// Module-private method - available in JS but not re-exported from public API
//wails:internal
func (s *AuthService) ValidateCredentials(username, password string) bool {
    // Implementation...
}
```

### Data Processing Service

Here's an example of a data processing service with generic types:

```go
package data

type ProcessingResult[T any] struct {
    Data  T
    Error string
}

type DataService struct {}

// Process processes data and returns a result
func (s *DataService) Process(data string) ProcessingResult[map[string]int] {
    // Implementation...
}

// ProcessBatch processes multiple data items
func (s *DataService) ProcessBatch(data []string) ProcessingResult[[]map[string]int] {
    // Implementation...
}

// Module-private method - available in JS but not re-exported from public API
//wails:internal
func (s *DataService) ParseData(data string) (map[string]int, error) {
    // Implementation...
}
```

### Conditional Code Injection

Here's an example of conditional code injection for different output formats:

```go
//wails:inject j*:/**
//wails:inject j*: * @param {string} arg
//wails:inject j*: * @returns {Promise<void>}
//wails:inject j*: */
//wails:inject j*:export async function CustomMethod(arg) {
//wails:inject t*:export async function CustomMethod(arg: string): Promise<void> {
//wails:inject     await InternalMethod("Hello " + arg + "!");
//wails:inject }
type Service struct{}
```

This injects different code for JavaScript and TypeScript outputs, providing appropriate type annotations for each language.

### The Internal + Inject Pattern

The `//wails:internal` and `//wails:inject` directives combine to create a powerful pattern: you mark Go methods as internal (module-private in JS) and then inject custom JavaScript that wraps them with a better API.

The built-in SQLite service uses this pattern extensively. Here is a simplified view:

```go
package sqlite

//wails:inject export {
//wails:inject     ExecContext as Execute,
//wails:inject     QueryContext as Query
//wails:inject };

type SQLiteService struct {
    // ...
}

// Execute is Go-only — frontend uses the injected re-export above.
//wails:ignore
func (s *SQLiteService) Execute(query string, args ...any) error {
    return s.ExecContext(context.Background(), query, args...)
}

// ExecContext is generated in JS but not publicly re-exported.
// The injected code above re-exports it as "Execute".
//wails:internal
func (s *SQLiteService) ExecContext(ctx context.Context, query string, args ...any) error {
    // Implementation...
}

// Query is Go-only — frontend uses the injected re-export above.
//wails:ignore
func (s *SQLiteService) Query(query string, args ...any) (Rows, error) {
    return s.QueryContext(context.Background(), query, args...)
}

// QueryContext is generated in JS but not publicly re-exported.
// The injected code above re-exports it as "Query".
//wails:internal
func (s *SQLiteService) QueryContext(ctx context.Context, query string, args ...any) (Rows, error) {
    // Implementation...
}
```

In this pattern:
- `//wails:ignore` on `Execute` and `Query` means they have **no JS presence at all** (Go-only convenience wrappers)
- `//wails:internal` on `ExecContext` and `QueryContext` means they **are generated in JS** but **not re-exported** from the index
- `//wails:inject` re-exports the internal methods under friendlier names (`Execute`, `Query`)

The SQLite service also uses `//wails:inject` to create a custom `Prepare()` function that wraps the internal `PrepareContext` method, transforming its return value into a rich `Stmt` object with `Close`, `Exec`, and `Query` methods — something that would not be possible with plain bindings alone.
