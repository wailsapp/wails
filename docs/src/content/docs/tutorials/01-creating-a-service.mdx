---
title: Creating a Service
sidebar:
  label: 1. Creating a Service
  order: 10
---

import { Steps } from "@astrojs/starlight/components";
import {Image } from 'astro:assets';

import qr1 from "../../../assets/qr1.png";

Services are the backbone of your application. They handle business logic and manage state.

In this guide, we'll create a new service that generates QR codes from text.
This will show you how to organize your code into reusable services and handle external dependencies.

<br/>

<Steps>

1. ## Create the QR Service file

   Create a new file called `qrservice.go` in your application directory and add the following code:

   ```go title="qrservice.go"
   package main

   import (
       "github.com/skip2/go-qrcode"
   )

   // QRService handles QR code generation
   type QRService struct {
       // We can add state here if needed
   }

   // NewQRService creates a new QR service
   func NewQRService() *QRService {
       return &QRService{}
   }

   // Generate creates a QR code from the given text
   func (s *QRService) Generate(text string, size int) ([]byte, error) {
       // Generate the QR code
       qr, err := qrcode.New(text, qrcode.Medium)
       if err != nil {
           return nil, err
       }

       // Convert to PNG
       png, err := qr.PNG(size)
       if err != nil {
           return nil, err
       }

       return png, nil
   }
   ```
    <br/>

2. ## Register the Service

   Update your `main.go` to use the new QR service:

   ```go title="main.go" ins={7-9}
    func main() {

        app := application.New(application.Options{
            Name:        "myproject",
            Description: "A demo of using raw HTML & CSS",
            LogLevel:    slog.LevelDebug,
            Services: []application.Service{
                application.NewService(NewQRService()),
            },
            Assets: application.AssetOptions{
                Handler: application.AssetFileServerFS(assets),
            },
            Mac: application.MacOptions{
                ApplicationShouldTerminateAfterLastWindowClosed: true,
            },
        })

        app.Window.NewWithOptions(application.WebviewWindowOptions{
            Title:  "myproject",
            Width:  600,
            Height: 400,
        })

        // Run the application. This blocks until the application has been exited.
        err := app.Run()

        // If an error occurred while running the application, log it and exit.
        if err != nil {
            log.Fatal(err)
        }
    }
   ```
    <br/>

3. ## Update go.mod

   Update your `go.mod` dependencies to include the `github.com/skip2/go-qrcode` package:

   ```go
   go mod tidy
   ```
    <br/>

4. ## Generate the Bindings

   To call these methods from your frontend, we need to generate bindings.
   You can do this by running `wails generate bindings` in your project root directory.

   :::note
   The very first time you ever run this in a project, the bindings generator does a thorough analysis of your code and dependencies. This can sometimes take a little longer than expected, however subsequent runs will be much faster.
   :::

   Once you've run this, you should see something similar to the following in your terminal:

   ```bash
    % wails3 generate bindings
    INFO  Processed: 337 Packages, 1 Service, 1 Method, 0 Enums, 0 Models in 740.196125ms.
    INFO  Output directory: /Users/leaanthony/myproject/frontend/bindings
   ```

   You should notice that in the frontend directory, there is a new directory called `bindings`:

   ```bash
   frontend/
   └── bindings
       └── changeme
           ├── index.js
           └── qrservice.js
   ```

    :::tip[Pro Tip]
        When you build your application using `wails3 build`, it will automatically generate bindings for you and keep them up to date.
    :::
    <br/>

5. ## Understanding the Bindings

   Let's look at the generated bindings in `bindings/changeme/qrservice.js`:

   ```js title="bindings/changeme/qrservice.js"
    // @ts-check
    // Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Â MODIWL
    // This file is automatically generated. DO NOT EDIT

    /**
     * QRService handles QR code generation
     * @module
     */

    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore: Unused imports
    import {Call as $Call, Create as $Create} from "@wailsio/runtime";

    /**
     * Generate creates a QR code from the given text
     * @param {string} text
     * @param {number} size
     * @returns {Promise<string> & { cancel(): void }}
     */
    export function Generate(text, size) {
        let $resultPromise = /** @type {any} */($Call.ByID(3576998831, text, size));
        let $typingPromise = /** @type {any} */($resultPromise.then(($result) => {
            return $Create.ByteSlice($result);
        }));
        $typingPromise.cancel = $resultPromise.cancel.bind($resultPromise);
        return $typingPromise;
    }
   ```

    We can see that the bindings are generated for the `Generate` method. The parameter names have been preserved,
    as well as the comments. JSDoc has also been generated for the method to provide type information to your IDE.

    :::note
    It's not necessary to fully understand the generated bindings, but it's important to understand how they work.
    :::

    The bindings provide:
    - Functions that are equivalent to your Go methods
    - Automatic conversion between Go and JavaScript types
    - Promise-based async operations
    - Type information as JSDoc comments

    :::tip[Typescript]
    The bindings generator also supports generating Typescript bindings. You can do this by running `wails3 generate bindings -ts`.
    :::

    The generated service is re-exported by an `index.js` file:

   ```js title="bindings/changeme/index.js"
    // @ts-check
    // Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Â MODIWL
    // This file is automatically generated. DO NOT EDIT

    import * as QRService from "./qrservice.js";
    export {
        QRService
    };
   ```

    You may then access it through the simplified import path
    `./bindings/changeme` consisting just of your Go package path,
    without specifying any file name.

    :::note
    Simplified import paths are only available when using frontend bundlers.
    If you prefer a vanilla frontend that does not employ a bundler,
    you will have to import either `index.js` or `qrservice.js` manually.
    :::
    <br/>

6. ## Use Bindings in Frontend

    Firstly, update `frontend/src/main.js` to use the new bindings:

   ```js title="frontend/src/main.js"
    import { QRService } from './bindings/changeme';

    async function generateQR() {
        const text = document.getElementById('text').value;
        if (!text) {
            alert('Please enter some text');
            return;
        }

        try {
            // Generate QR code as base64
            const qrCodeBase64 = await QRService.Generate(text, 256);

            // Display the QR code
            const qrDiv = document.getElementById('qrcode');
            qrDiv.src = `data:image/png;base64,${qrCodeBase64}`;

        } catch (err) {
            console.error('Failed to generate QR code:', err);
            alert('Failed to generate QR code: ' + err);
        }
    }

    export function initializeQRGenerator() {
        const button = document.getElementById('generateButton');
        button.addEventListener('click', generateQR);
    }
   ```

   Now update `index.html` to use the new bindings in the `initializeQRGenerator` function:

    ```html title="frontend/src/index.html"
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>QR Code Generator</title>
                <style>
                    body {
                    font-family: Arial, sans-serif;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: center;
                    height: 100vh;
                    margin: 0;
                }
                    #qrcode {
                    margin-bottom: 20px;
                    width: 256px;
                    height: 256px;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                }
                    #controls {
                    display: flex;
                    gap: 10px;
                }
                    #text {
                    padding: 5px;
                }
                    #generateButton {
                    padding: 5px 10px;
                    cursor: pointer;
                }
                </style>
    </head>
    <body>
    <img id="qrcode"/>
    <div id="controls">
        <input type="text" id="text" placeholder="Enter text">
            <button id="generateButton">Generate QR Code</button>
    </div>

    <script type="module">
        import { initializeQRGenerator } from './main.js';
        document.addEventListener('DOMContentLoaded', initializeQRGenerator);
    </script>
    </body>
    </html>
    ```

    Run `wails3 dev` to start the dev server. After a few seconds, the application should open.

    Type in some text and click the "Generate QR Code" button. You should see a QR code in the center of the page:

    <Image src={qr1} alt="QR Code"/>

    <br/>
    <br/>

7. ## Alternative Approach

    So far, we have covered the following areas:
    - Creating a new Service
    - Generating Bindings
    - Using the Bindings in our Frontend code

    If the aim of your service is to serve files/assets/media to the frontend, like a traditional web server,
    then there is an alternative approach to achieve the same result.

    If your service defines Go's standard http handler function `ServeHTTP(w http.ResponseWriter, r *http.Request)`,
    then it can be made accessible on the frontend. Let's extend our QR code service to do this:

    ```go title="qrservice.go" ins={4-5,37-65}
    package main

    import (
        "net/http"
        "strconv"

        "github.com/skip2/go-qrcode"
    )

    // QRService handles QR code generation
    type QRService struct {
        // We can add state here if needed
    }

    // NewQRService creates a new QR service
    func NewQRService() *QRService {
        return &QRService{}
    }

    // Generate creates a QR code from the given text
    func (s *QRService) Generate(text string, size int) ([]byte, error) {
        // Generate the QR code
        qr, err := qrcode.New(text, qrcode.Medium)
        if err != nil {
            return nil, err
        }

        // Convert to PNG
        png, err := qr.PNG(size)
        if err != nil {
            return nil, err
        }

        return png, nil
    }

    func (s *QRService) ServeHTTP(w http.ResponseWriter, r *http.Request) {
        // Extract the text parameter from the request
        text := r.URL.Query().Get("text")
        if text == "" {
            http.Error(w, "Missing 'text' parameter", http.StatusBadRequest)
            return
        }
        // Extract Size parameter from the request
        sizeText := r.URL.Query().Get("size")
        if sizeText == "" {
            sizeText = "256"
        }
        size, err := strconv.Atoi(sizeText)
        if err != nil {
            http.Error(w, "Invalid 'size' parameter", http.StatusBadRequest)
            return
        }

        // Generate the QR code
        qrCodeData, err := s.Generate(text, size)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }

        // Write the QR code data to the response
        w.Header().Set("Content-Type", "image/png")
        w.Write(qrCodeData)
    }
    ```

    Now update `main.go` to specify the route that the QR code service should be accessible on:

   ```go title="main.go" ins={8-10}
    func main() {

        app := application.New(application.Options{
            Name:        "myproject",
            Description: "A demo of using raw HTML & CSS",
            LogLevel:    slog.LevelDebug,
            Services: []application.Service{
                application.NewService(NewQRService(), application.ServiceOptions{
                    Route: "/qrservice",
                }),
            },
            Assets: application.AssetOptions{
                Handler: application.AssetFileServerFS(assets),
            },
            Mac: application.MacOptions{
                ApplicationShouldTerminateAfterLastWindowClosed: true,
            },
        })

        app.Window.NewWithOptions(application.WebviewWindowOptions{
            Title:  "myproject",
            Width:  600,
            Height: 400,
        })

        // Run the application. This blocks until the application has been exited.
        err := app.Run()

        // If an error occurred while running the application, log it and exit.
        if err != nil {
            log.Fatal(err)
        }
    }
   ```

    :::note
    If you do not set the `Route` option explicitly,
    the HTTP handler won't be accessible from the frontend.
    :::

    Finally, update `main.js` to make the image source the path to the QR code service, passing the text as a query parameter:

    ```js title="frontend/src/main.js"
    async function generateQR() {
        const text = document.getElementById('text').value;
        if (!text) {
            alert('Please enter some text');
            return;
        }

        const img = document.getElementById('qrcode');
        // Make the image source the path to the QR code service, passing the text
        img.src = `/qrservice?text=${encodeURIComponent(text)}`
    }

    export function initializeQRGenerator() {
        const button = document.getElementById('generateButton');
        if (button) {
            button.addEventListener('click', generateQR);
        } else {
            console.error('Generate button not found');
        }
    }
    ```

    Running the application again should result in the same QR code:

    <Image src={qr1} alt="QR Code"/>
    <br/>

8. ## Supporting dynamic configurations

    In the example above we used a hardcoded route `/qrservice`.
    If you edit `main.go` and change the `Route` option without updating `main.js`,
    the application will break:

    ```go title="main.go" ins={3}
            // ...
                application.NewService(NewQRService(), application.ServiceOptions{
                    Route: "/services/qr",
                }),
            // ...
    ```

    Hardcoded routes can be good for many applications,
    but if you need more flexibility, method bindings and HTTP handlers
    can work together to improve the development experience.

    The `ServiceStartup` Lifecycle method provides access to service options at startup,
    and a custom method can be used to announce the configured route to the frontend.

    First, implement the `ServiceStartup` interface and add a new `URL` method:

    ```go title="qrservice.go" ins={4,6,10,15,23-27,46-55}
    package main

    import (
        "context"
        "net/http"
        "net/url"
        "strconv"

        "github.com/skip2/go-qrcode"
        "github.com/wailsapp/wails/v3/pkg/application"
    )

    // QRService handles QR code generation
    type QRService struct {
        route string
    }

    // NewQRService creates a new QR service
    func NewQRService() *QRService {
        return &QRService{}
    }

    // ServiceStartup runs at application startup.
    func (s *QRService) ServiceStartup(ctx context.Context, options application.ServiceOptions) error {
        s.route = options.Route
        return nil
    }

    // Generate creates a QR code from the given text
    func (s *QRService) Generate(text string, size int) ([]byte, error) {
        // Generate the QR code
        qr, err := qrcode.New(text, qrcode.Medium)
        if err != nil {
            return nil, err
        }

        // Convert to PNG
        png, err := qr.PNG(size)
        if err != nil {
            return nil, err
        }

        return png, nil
    }

    // URL returns an URL that may be used to fetch
    // a QR code with the given text and size.
    // It returns an error if the HTTP handler is not available.
    func (s *QRService) URL(text string, size int) (string, error) {
        if s.route == "" {
            return "", errors.New("http handler unavailable")
        }

        return fmt.Sprintf("%s?text=%s&size=%d", s.route, url.QueryEscape(text), size), nil
    }

    func (s *QRService) ServeHTTP(w http.ResponseWriter, r *http.Request) {
        // Extract the text parameter from the request
        text := r.URL.Query().Get("text")
        if text == "" {
            http.Error(w, "Missing 'text' parameter", http.StatusBadRequest)
            return
        }
        // Extract Size parameter from the request
        sizeText := r.URL.Query().Get("size")
        if sizeText == "" {
            sizeText = "256"
        }
        size, err := strconv.Atoi(sizeText)
        if err != nil {
            http.Error(w, "Invalid 'size' parameter", http.StatusBadRequest)
            return
        }

        // Generate the QR code
        qrCodeData, err := s.Generate(text, size)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }

        // Write the QR code data to the response
        w.Header().Set("Content-Type", "image/png")
        w.Write(qrCodeData)
    }
    ```

    Now update `main.js` to use the `URL` method in place of a hardcoded path:

    ```js title="frontend/src/main.js" ins={1,11-12}
    import { QRService } from "./bindings/changeme";

    async function generateQR() {
        const text = document.getElementById('text').value;
        if (!text) {
            alert('Please enter some text');
            return;
        }

        const img = document.getElementById('qrcode');
        // Invoke the URL method to obtain an URL for the given text.
        img.src = await QRService.URL(text, 256);
    }

    export function initializeQRGenerator() {
        const button = document.getElementById('generateButton');
        if (button) {
            button.addEventListener('click', generateQR);
        } else {
            console.error('Generate button not found');
        }
    }
    ```

    It should work just like the previous example,
    but changing the service route in `main.go`
    will not break the frontend anymore.

    :::note
    If a Go method returns a non-nil error,
    the promise on the JS side will reject
    and await statements will throw an exception.
    :::
    <br/>

</Steps>
