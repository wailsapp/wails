---
title: TODO List App
description: Build a complete TODO list application with CRUD operations
sidebar:
  order: 2
---

import { Tabs, TabItem, Steps } from "@astrojs/starlight/components";

Build a complete TODO list application that demonstrates practical Wails concepts:
- CRUD operations (Create, Read, Update, Delete)
- Thread-safe state management
- Modern UI design
- Type-safe bindings

**Time to complete:** 20 minutes

## Create Your Project

<Steps>

1. **Generate the project**

   ```bash
   wails3 init -n todo-app
   cd todo-app
   ```

2. **Create the TODO service**

   Delete `greetservice.go` and create a new file `todoservice.go`:

   ```go title="todoservice.go"
   package main

   import (
       "errors"
       "sync"
   )

   type Todo struct {
       ID        int    `json:"id"`
       Title     string `json:"title"`
       Completed bool   `json:"completed"`
   }

   type TodoService struct {
       todos  []Todo
       nextID int
       mu     sync.RWMutex
   }

   func NewTodoService() *TodoService {
       return &TodoService{
           todos:  []Todo{},
           nextID: 1,
       }
   }

   func (t *TodoService) GetAll() []Todo {
       t.mu.RLock()
       defer t.mu.RUnlock()
       return t.todos
   }

   func (t *TodoService) Add(title string) (*Todo, error) {
       if title == "" {
           return nil, errors.New("title cannot be empty")
       }

       t.mu.Lock()
       defer t.mu.Unlock()

       todo := Todo{
           ID:        t.nextID,
           Title:     title,
           Completed: false,
       }
       t.todos = append(t.todos, todo)
       t.nextID++

       return &todo, nil
   }

   func (t *TodoService) Toggle(id int) error {
       t.mu.Lock()
       defer t.mu.Unlock()

       for i := range t.todos {
           if t.todos[i].ID == id {
               t.todos[i].Completed = !t.todos[i].Completed
               return nil
           }
       }
       return errors.New("todo not found")
   }

   func (t *TodoService) Delete(id int) error {
       t.mu.Lock()
       defer t.mu.Unlock()

       for i, todo := range t.todos {
           if todo.ID == id {
               t.todos = append(t.todos[:i], t.todos[i+1:]...)
               return nil
           }
       }
       return errors.New("todo not found")
   }
   ```

   **What's happening here:**
   - `sync.RWMutex` provides thread-safe access to the todos slice
   - Each method locks appropriately (read lock for GetAll, write lock for mutations)
   - IDs are auto-incremented for each new TODO
   - Errors are returned for invalid operations

3. **Update main.go**

   Update the service registration in `main.go`:

   ```go title="main.go" {5}
   Services: []application.Service{
       application.NewService(NewTodoService()),
   },
   ```

4. **Create the frontend UI**

   Replace `frontend/src/main.js`:

   ```javascript title="frontend/src/main.js"
   import {TodoService} from "../bindings/changeme";

   async function loadTodos() {
       const todos = await TodoService.GetAll();
       const list = document.getElementById('todo-list');

       list.innerHTML = todos.map(todo => `
           <div class="todo ${todo.completed ? 'completed' : ''}">
               <input type="checkbox"
                      ${todo.completed ? 'checked' : ''}
                      onchange="toggleTodo(${todo.id})">
               <span>${todo.title}</span>
               <button onclick="deleteTodo(${todo.id})">Delete</button>
           </div>
       `).join('');
   }

   window.addTodo = async () => {
       const input = document.getElementById('todo-input');
       const title = input.value.trim();

       if (title) {
           await TodoService.Add(title);
           input.value = '';
           await loadTodos();
       }
   }

   window.toggleTodo = async (id) => {
       await TodoService.Toggle(id);
       await loadTodos();
   }

   window.deleteTodo = async (id) => {
       await TodoService.Delete(id);
       await loadTodos();
   }

   // Load todos on startup
   loadTodos();
   ```

5. **Update the HTML**

   Replace `frontend/index.html`:

   ```html title="frontend/index.html"
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8"/>
       <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
       <title>TODO App</title>
       <link rel="stylesheet" href="./public/style.css"/>
   </head>
   <body>
       <div class="container">
           <h1>My TODOs</h1>
           <div class="card">
               <div class="input-box">
                   <input type="text"
                          id="todo-input"
                          class="input"
                          placeholder="Add a new todo..."
                          onkeypress="if(event.key==='Enter') addTodo()">
                   <button class="btn" onclick="addTodo()">Add</button>
               </div>
               <div id="todo-list"></div>
           </div>
       </div>
       <script type="module" src="./src/main.js"></script>
   </body>
   </html>
   ```

6. **Style the app**

   Replace `frontend/public/style.css`:

   ```css title="frontend/public/style.css"
   :root {
       font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto",
       "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue",
       sans-serif;
       font-size: 16px;
       background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
       color: rgba(255, 255, 255, 0.87);
   }

   body {
       margin: 0;
       display: flex;
       place-items: center;
       min-height: 100vh;
   }

   .container {
       width: 100%;
       max-width: 600px;
       padding: 20px;
   }

   h1 {
       text-align: center;
       color: white;
       font-size: 2.5em;
       font-weight: 300;
       margin: 0 0 30px 0;
       text-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
   }

   .card {
       background: rgba(255, 255, 255, 0.95);
       backdrop-filter: blur(10px);
       border-radius: 16px;
       padding: 30px;
       box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
   }

   .input-box {
       display: flex;
       gap: 10px;
       margin-bottom: 25px;
   }

   .input {
       flex: 1;
       border: 2px solid #e0e0e0;
       border-radius: 12px;
       height: 50px;
       padding: 0 20px;
       font-size: 16px;
       transition: all 0.3s ease;
   }

   .input:focus {
       border-color: #667eea;
       outline: none;
       box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
   }

   .btn {
       height: 50px;
       padding: 0 30px;
       border: none;
       border-radius: 12px;
       background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
       color: white;
       font-weight: 600;
       cursor: pointer;
       transition: all 0.3s ease;
       box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
   }

   .btn:hover {
       transform: translateY(-2px);
       box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
   }

   #todo-list {
       display: flex;
       flex-direction: column;
       gap: 10px;
   }

   .todo {
       display: flex;
       align-items: center;
       padding: 18px 20px;
       background: white;
       border: 2px solid #f0f0f0;
       border-radius: 12px;
       transition: all 0.3s ease;
       gap: 15px;
   }

   .todo:hover {
       border-color: #667eea;
       box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
       transform: translateX(4px);
   }

   .todo.completed {
       opacity: 0.6;
   }

   .todo.completed span {
       text-decoration: line-through;
       color: #999;
   }

   .todo input[type="checkbox"] {
       width: 24px;
       height: 24px;
       cursor: pointer;
       appearance: none;
       -webkit-appearance: none;
       border: 2px solid #667eea;
       border-radius: 6px;
       position: relative;
       transition: all 0.3s ease;
       flex-shrink: 0;
   }

   .todo input[type="checkbox"]:hover {
       background: rgba(102, 126, 234, 0.1);
   }

   .todo input[type="checkbox"]:checked {
       background: #667eea;
       border-color: #667eea;
   }

   .todo input[type="checkbox"]:checked::after {
       content: 'âœ“';
       position: absolute;
       color: white;
       font-size: 16px;
       font-weight: bold;
       top: 50%;
       left: 50%;
       transform: translate(-50%, -50%);
   }

   .todo span {
       flex: 1;
       font-size: 16px;
       color: #333;
   }

   .todo button {
       padding: 8px 16px;
       background: #ff4757;
       color: white;
       border: none;
       border-radius: 8px;
       font-size: 14px;
       font-weight: 600;
       cursor: pointer;
       transition: all 0.3s ease;
       opacity: 0;
       flex-shrink: 0;
   }

   .todo:hover button {
       opacity: 1;
   }

   .todo button:hover {
       background: #ee5a6f;
       transform: scale(1.05);
   }

   #todo-list:empty::before {
       content: "No todos yet. Add one above!";
       display: block;
       text-align: center;
       padding: 40px 20px;
       color: #999;
   }
   ```

7. **Run the app**

   ```bash
   wails3 dev
   ```

   Try adding, completing, and deleting todos. Notice how the UI updates instantly after each operation.

</Steps>

## How It Works

### Thread-Safe State Management

The `sync.RWMutex` provides safe concurrent access:

```go
func (t *TodoService) GetAll() []Todo {
    t.mu.RLock()  // Read lock - multiple readers allowed
    defer t.mu.RUnlock()
    return t.todos
}

func (t *TodoService) Add(title string) (*Todo, error) {
    t.mu.Lock()  // Write lock - exclusive access
    defer t.mu.Unlock()
    // ... mutations
}
```

**Why this matters:**
- Multiple frontend calls can happen concurrently
- Read operations don't block each other
- Write operations get exclusive access
- `defer` ensures locks are always released

### Error Handling

The service returns errors for invalid operations:

```go
func (t *TodoService) Add(title string) (*Todo, error) {
    if title == "" {
        return nil, errors.New("title cannot be empty")
    }
    // ...
}
```

In the frontend, you can catch these:

```javascript
try {
    await TodoService.Add(title);
} catch (err) {
    alert('Error: ' + err);
}
```

### State Synchronization

After each mutation, we reload the full list:

```javascript
window.addTodo = async () => {
    await TodoService.Add(title);  // Mutation
    await loadTodos();             // Refresh
}
```

**Alternative approach:** Return the updated list from each method to avoid the second call.

## Enhancements

### Add Statistics

Add this to `todoservice.go`:

```go
type TodoStats struct {
    Total     int `json:"total"`
    Completed int `json:"completed"`
    Active    int `json:"active"`
}

func (t *TodoService) GetStats() TodoStats {
    t.mu.RLock()
    defer t.mu.RUnlock()

    stats := TodoStats{
        Total: len(t.todos),
    }

    for _, todo := range t.todos {
        if todo.Completed {
            stats.Completed++
        } else {
            stats.Active++
        }
    }

    return stats
}
```

Display in the frontend:

```javascript
async function loadTodos() {
    const [todos, stats] = await Promise.all([
        TodoService.GetAll(),
        TodoService.GetStats()
    ]);

    // Display stats
    document.getElementById('stats').textContent =
        `${stats.active} active, ${stats.completed} completed`;

    // ... render todos
}
```

### Add "Clear Completed"

```go
func (t *TodoService) ClearCompleted() int {
    t.mu.Lock()
    defer t.mu.Unlock()

    removed := 0
    newTodos := []Todo{}

    for _, todo := range t.todos {
        if !todo.Completed {
            newTodos = append(newTodos, todo)
        } else {
            removed++
        }
    }

    t.todos = newTodos
    return removed
}
```

### Add Persistence

For production apps, you'd typically add database persistence. See the [Database Integration](/guides/patterns/database) guide for examples with SQLite, PostgreSQL, etc.

## Build for Production

```bash
wails3 build
```

Your TODO app is now a native executable in `build/bin/`.

## What We Learned

**CRUD Operations**
- Create (Add), Read (GetAll), Update (Toggle), Delete (Delete)
- Error handling for invalid operations
- Proper return types for each operation

**Thread Safety**
- `sync.RWMutex` for concurrent access
- Read locks vs write locks
- Deferred unlocking to prevent deadlocks

**Modern UI**
- Gradient backgrounds
- Glassmorphic design
- Custom checkbox styling
- Hover effects and transitions
- Empty state messaging

**State Management**
- Centralized state in Go
- Frontend as view layer
- Refresh pattern after mutations

---

**Next:** Try adding [database persistence](/guides/patterns/database) or building a [system tray app](/tutorials/system-tray).
