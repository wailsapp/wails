---
title: Binding Best Practices
sidebar:
  order: 23
---

import { FileTree } from "@astrojs/starlight/components";

This guide provides best practices and patterns for using the Wails binding system effectively in your applications.

## Service Design Patterns

### Service Organization

Organize your services based on functionality rather than technical concerns. For example, instead of having a single large service, split it into smaller, focused services:

```go
// Instead of this:
type AppService struct {}

func (s *AppService) GetUser() User { /* ... */ }
func (s *AppService) UpdateUser(user User) error { /* ... */ }
func (s *AppService) GetProducts() []Product { /* ... */ }
func (s *AppService) AddProduct(product Product) error { /* ... */ }

// Do this:
type UserService struct {}
func (s *UserService) GetUser() User { /* ... */ }
func (s *UserService) UpdateUser(user User) error { /* ... */ }

type ProductService struct {}
func (s *ProductService) GetProducts() []Product { /* ... */ }
func (s *ProductService) AddProduct(product Product) error { /* ... */ }
```

This makes your code more maintainable and easier to understand.

### Use JSON Tags

Use JSON tags to control how your models are serialized:

```go
type User struct {
    ID        int       `json:"id"`
    Name      string    `json:"name"`
    Email     string    `json:"email"`
    Password  string    `json:"-"`  // Exclude from JSON
    CreatedAt time.Time `json:"created_at"`
    UpdatedAt time.Time `json:"updated_at"`
}
```

### Separate Frontend and Backend Models

Consider using different models for the frontend and backend:

```go
// Backend model
type User struct {
    ID        int
    Name      string
    Email     string
    Password  string  // Sensitive data
    CreatedAt time.Time
    UpdatedAt time.Time
}

// Frontend model
type UserDTO struct {
    ID        int       `json:"id"`
    Name      string    `json:"name"`
    Email     string    `json:"email"`
    CreatedAt time.Time `json:"created_at"`
}

func (s *UserService) GetUser() UserDTO {
    user := getUserFromDatabase()
    return UserDTO{
        ID:        user.ID,
        Name:      user.Name,
        Email:     user.Email,
        CreatedAt: user.CreatedAt,
    }
}
```

This gives you more control over what data is exposed to the frontend.

### Use Context for Cancellation

Use context for cancellation to avoid wasting resources on abandoned requests:

```go
func (s *ProductService) GetProducts(ctx context.Context, req ProductsRequest) (ProductsResponse, error) {
    // Check if the request has been cancelled
    select {
    case <-ctx.Done():
        return ProductsResponse{}, ctx.Err()
    default:
        // Continue processing
    }

    products, total, err := getProductsFromDatabase(ctx, req.Page, req.PageSize, req.Filter)
    if err != nil {
        return ProductsResponse{}, err
    }

    return ProductsResponse{
        Products: products,
        Total:    total,
        Page:     req.Page,
        PageSize: req.PageSize,
    }, nil
}
```
