package binding

import (
	"bytes"
	_ "embed"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"github.com/wailsapp/wails/v2/internal/fs"

	"github.com/leaanthony/slicer"
)

var (
	mapRegex          *regexp.Regexp
	keyPackageIndex   int
	keyTypeIndex      int
	valueArrayIndex   int
	valuePackageIndex int
	valueTypeIndex    int
)

func init() {
	mapRegex = regexp.MustCompile(`(?:map\[(?:(?P<keyPackage>\w+)\.)?(?P<keyType>\w+)])?(?P<valueArray>\[])?(?:\*?(?P<valuePackage>\w+)\.)?(?P<valueType>.+)`)
	keyPackageIndex = mapRegex.SubexpIndex("keyPackage")
	keyTypeIndex = mapRegex.SubexpIndex("keyType")
	valueArrayIndex = mapRegex.SubexpIndex("valueArray")
	valuePackageIndex = mapRegex.SubexpIndex("valuePackage")
	valueTypeIndex = mapRegex.SubexpIndex("valueType")
}

func (b *Bindings) GenerateGoBindings(baseDir string) error {
	store := b.db.store
	var obfuscatedBindings map[string]int
	if b.obfuscate {
		obfuscatedBindings = b.db.UpdateObfuscatedCallMap()
	}
	for packageName, structs := range store {
		packageDir := filepath.Join(baseDir, packageName)
		err := fs.Mkdir(packageDir)
		if err != nil {
			return err
		}
		for structName, methods := range structs {
			var jsoutput bytes.Buffer
			jsoutput.WriteString(`// @ts-check
// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Â MODIWL
// This file is automatically generated. DO NOT EDIT
`)
			var tsBody bytes.Buffer
			var tsContent bytes.Buffer
			tsContent.WriteString(`// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Â MODIWL
// This file is automatically generated. DO NOT EDIT
`)
			// Sort the method names alphabetically
			methodNames := make([]string, 0, len(methods))
			for methodName := range methods {
				methodNames = append(methodNames, methodName)
			}
			sort.Strings(methodNames)

			var importNamespaces slicer.StringSlicer
			for _, methodName := range methodNames {
				// Get the method details
				methodDetails := methods[methodName]

				// Generate JS
				var args slicer.StringSlicer
				for count := range methodDetails.Inputs {
					arg := fmt.Sprintf("arg%d", count+1)
					args.Add(arg)
				}
				argsString := args.Join(", ")
				jsoutput.WriteString(fmt.Sprintf("\nexport function %s(%s) {", methodName, argsString))
				jsoutput.WriteString("\n")
				if b.obfuscate {
					id := obfuscatedBindings[strings.Join([]string{packageName, structName, methodName}, ".")]
					jsoutput.WriteString(fmt.Sprintf("  return ObfuscatedCall(%d, [%s]);", id, argsString))
				} else {
					jsoutput.WriteString(fmt.Sprintf("  return window['go']['%s']['%s']['%s'](%s);", packageName, structName, methodName, argsString))
				}
				jsoutput.WriteString("\n}\n")

				// Generate TS
				tsBody.WriteString(fmt.Sprintf("\nexport function %s(", methodName))

				args.Clear()
				for count, input := range methodDetails.Inputs {
					arg := fmt.Sprintf("arg%d", count+1)
					entityName := entityFullReturnType(input.TypeName, b.tsPrefix, b.tsSuffix, &importNamespaces)
					args.Add(arg + ":" + goTypeToTypescriptType(entityName, &importNamespaces))
				}
				tsBody.WriteString(args.Join(",") + "):")
				// now build Typescript return types
				// If there is no return value or only returning error, TS returns Promise<void>
				// If returning single value, TS returns Promise<type>
				// If returning single value or error, TS returns Promise<type>
				// If returning two values, TS returns Promise<type1|type2>
				// Otherwise, TS returns Promise<type1> (instead of throwing Go error?)
				var returnType string
				if methodDetails.OutputCount() == 0 {
					returnType = "Promise<void>"
				} else if methodDetails.OutputCount() == 1 && methodDetails.Outputs[0].TypeName == "error" {
					returnType = "Promise<void>"
				} else {
					outputTypeName := entityFullReturnType(methodDetails.Outputs[0].TypeName, b.tsPrefix, b.tsSuffix, &importNamespaces)
					firstType := goTypeToTypescriptType(outputTypeName, &importNamespaces)
					returnType = "Promise<" + firstType
					if methodDetails.OutputCount() == 2 && methodDetails.Outputs[1].TypeName != "error" {
						outputTypeName = entityFullReturnType(methodDetails.Outputs[1].TypeName, b.tsPrefix, b.tsSuffix, &importNamespaces)
						secondType := goTypeToTypescriptType(outputTypeName, &importNamespaces)
						returnType += "|" + secondType
					}
					returnType += ">"
				}
				tsBody.WriteString(returnType + ";\n")
			}

			importNamespaces.Deduplicate()
			importNamespaces.Each(func(namespace string) {
				tsContent.WriteString("import {" + namespace + "} from '../models';\n")
			})
			tsContent.WriteString(tsBody.String())

			jsfilename := filepath.Join(packageDir, structName+".js")
			err = os.WriteFile(jsfilename, jsoutput.Bytes(), 0o755)
			if err != nil {
				return err
			}
			tsfilename := filepath.Join(packageDir, structName+".d.ts")
			err = os.WriteFile(tsfilename, tsContent.Bytes(), 0o755)
			if err != nil {
				return err
			}
		}
	}
	err := b.WriteModels(baseDir)
	if err != nil {
		return err
	}
	return nil
}

var customTypeMap = map[string]string{
	"time.Time": "string",
	"uuid.UUID": "string",
}

func fullyQualifiedName(packageName string, typeName string) string {
	fullType := typeName
	if len(packageName) > 0 {
		fullType = packageName + "." + typeName
	}

	if tsType, ok := customTypeMap[fullType]; ok {
		return tsType
	}

	switch true {
	case len(typeName) == 0:
		return ""
	case typeName == "interface{}" || typeName == "interface {}":
		return "any"
	case typeName == "string":
		return "string"
	case typeName == "error":
		return "Error"
	case
		strings.HasPrefix(typeName, "int"),
		strings.HasPrefix(typeName, "uint"),
		strings.HasPrefix(typeName, "float"):
		return "number"
	case typeName == "bool":
		return "boolean"
	default:
		return "any"
	}
}

var (
	jsVariableUnsafeChars = regexp.MustCompile(`[^A-Za-z0-9_]`)
	genericTypePattern    = regexp.MustCompile(`^(.*)\[(.*)\]$`)
)

func arrayifyValue(valueArray string, valueType string) string {
	valueType = strings.ReplaceAll(valueType, "*", "")
	gidx := strings.IndexRune(valueType, '[')
	if gidx > 0 { // its a generic type
		rem := strings.SplitN(valueType, "[", 2)
		valueType = rem[0] + "_" + jsVariableUnsafeChars.ReplaceAllLiteralString(rem[1], "_")
	}

	if len(valueArray) == 0 {
		return valueType
	}

	return "Array<" + valueType + ">"
}

// goTypeToJSDocType converts a Go type string to a JSDoc/TypeScript type string.
func goTypeToJSDocType(goType string) string {
	goType = strings.TrimSpace(goType)

	// Handle pointers
	for strings.HasPrefix(goType, "*") {
		goType = strings.TrimPrefix(goType, "*")
		goType = strings.TrimSpace(goType)
	}

	// Special-case []byte -> string
	if goType == "[]byte" {
		return "string"
	}

	// Handle arrays/slices in legacy "Array<>" style
	if strings.HasPrefix(goType, "[]") {
		elemType := strings.TrimPrefix(goType, "[]")
		elemJS := goTypeToJSDocType(elemType)
		return fmt.Sprintf("Array<%s>", elemJS)
	}

	// Handle maps with bracket-depth logic
	if strings.HasPrefix(goType, "map[") {
		keyStart := len("map[")
		depth := 1
		keyEnd := -1
		for i, r := range goType[keyStart:] {
			switch r {
			case '[':
				depth++
			case ']':
				depth--
				if depth == 0 {
					keyEnd = keyStart + i
					break
				}
			}
			if keyEnd != -1 {
				break
			}
		}
		if keyEnd == -1 || keyEnd+1 >= len(goType) {
			return "any"
		}
		keyType := goType[keyStart:keyEnd]
		valType := strings.TrimSpace(goType[keyEnd+1:])
		return fmt.Sprintf("Record<%s, %s>", goTypeToJSDocType(keyType), goTypeToJSDocType(valType))
	}

	// Generic type pattern (legacy underscore flattening)
	// Note: This pattern matches the innermost brackets for nested generics.
	// Nested generics like Outer[Inner[T]] are not currently supported.
	if matches := genericTypePattern.FindStringSubmatch(goType); len(matches) == 3 {
		base := matches[1]
		inner := jsVariableUnsafeChars.ReplaceAllLiteralString(matches[2], "_")
		inner = strings.TrimPrefix(inner, "_") // remove leading underscore if any
		return fmt.Sprintf("%s_%s_", base, inner)
	}

	// If fully qualified and not in customTypeMap, use name unchanged
	if strings.Contains(goType, ".") {
		// Check if this is a custom type that should be mapped
		if tsType, ok := customTypeMap[goType]; ok {
			return tsType
		}

		// Normal fully-qualified name (main.SomeType)
		if !strings.Contains(goType, "[") {
			return goType
		}
	}

	// customTypeMap lookup for base name
	if mapped, ok := customTypeMap[goType]; ok {
		return mapped
	}

	// Basic mappings
	switch goType {
	case "string":
		return "string"
	case "error":
		return "Error"
	case "bool":
		return "boolean"
	case "interface{}":
		return "any"
	case "int", "int8", "int16", "int32", "int64",
		"uint", "uint8", "uint16", "uint32", "uint64",
		"float32", "float64":
		return "number"
	}

	return "any"
}

func goTypeToTypescriptType(input string, _ *slicer.StringSlicer) string {
	return goTypeToJSDocType(input)
}

func entityFullReturnType(input, prefix, suffix string, importNamespaces *slicer.StringSlicer) string {
	if strings.ContainsRune(input, '.') {
		nameSpace, returnType := getSplitReturn(input)
		return nameSpace + "." + prefix + returnType + suffix
	}

	return input
}
