---
sidebar_position: 20
---

# Wie funktioniert es?

Eine Wails Anwendung ist eine Standard-Go-Anwendung mit einem Webkit Frontend. Der Go-Teil der Anwendung besteht aus dem Anwendungscode und einer Laufzeitbibliothek, die eine Reihe nützlicher Operationen bietet, wie die Kontrolle des Anwendungsfensters. Das Frontend ist ein Webkit-Fenster, das die Frontend-Assets anzeigt. Im Frontend ist auch eine JavaScript- Version der Laufzeitbibliothek verfügbar. Schließlich ist es möglich, Go-Methoden an das Frontend zu binden. Diese erscheinen dann als JavaScript-Methoden, die aufgerufen werden können, als ob es sich um lokale JavaScript-Methoden handeln würde.

```mdx-code-block
<div className="text--center">
  <img src={require("@site/static/img/architecture.webp").default} style={{"width":"75%", "max-width":"800px"}} />
</div>
```

## Die Hauptanwendung

### Übersicht

Die Hauptanwendung besteht aus einem einzigen Aufruf von `wails.Run()`. Es akzeptiert die App-Konfiguration, welche beispielsweise die Größe des Anwendungsfensters, den Fenstertitel, sowie welche Assets verwendet werden sollen, beschreibt. Eine einfache Anwendung könnte so aussehen:

```go title="main.go"
package main

import (
    "embed"
    "log"

    "github.com/wailsapp/wails/v2"
    "github.com/wailsapp/wails/v2/pkg/options"
  "github.com/wailsapp/wails/v2/pkg/options/assetserver"
)

//go:embed all:frontend/dist
var assets embed.FS

func main() {

    app := &App{}

    err := wails.Run(&options.App{
        Title:  "Basic Demo",
        Width:  1024,
        Height: 768,
        AssetServer: &assetserver.Options{
            Assets: assets,
        },
        OnStartup:  app.startup,
        OnShutdown: app.shutdown,
        Bind: []interface{}{
            app,
        },
    })
    if err != nil {
        log.Fatal(err)
    }
}


type App struct {
    ctx context.Context
}

func (b *App) startup(ctx context.Context) {
    b.ctx = ctx
}

func (b *App) shutdown(ctx context.Context) {}

func (b *App) Greet(name string) string {
    return fmt.Sprintf("Hello %s!", name)
}
```

### Optionen

Dieses Beispiel hat die folgenden Optionen gesetzt:

- `Titel` - Der Text, der in der Titelleiste des Fensters erscheinen soll
- `Breite` & `Höhe` - Die Größe des Fensters
- `Assets` - Frontend Assets der Anwendung
- `OnStartup` - Ein Rückruf, welcher zwischen der Fenstererstellung und Frontend Asset Ladung aufgerufen wird
- `OnShutdown` - Ein Rückruf, der aufgerufen wird, sobald die Anwendung geschlossen wird
- `Bind` - Ein slice von struct Instanzen, die im Frontend verfügbar sein sollen

Eine vollständige Liste der Anwendungsoptionen in der [Optionenreferenz](reference/options.mdx).

#### Assets

Die Option `Assets` ist obligatorisch, da es keine Wails Anwendung ohne Frontend-Assets geben kann. Diese Assets können alle Dateien sein, die du in einer Web-Anwendung finden kannst - html, js, css, svg, png, etc. ** Es ist nicht erforderlich, Asset-Bundles zu generieren** - Source Dateien reichen aus. Wenn die Anwendung startet, wird versucht, aus den Assets, `Index.html` zu laden und von diesem Zeitpunkt an funktioniert das Frontend im Wesentlichen wie ein Browser. Nützlich, zu wissen ist, dass es keine Voraussetzungen dafür gibt, wo in der `embed.FS` die Dateien liegen. Es ist wahrscheinlich, dass der Embed Pfad ein verschachteltes Verzeichnis relativ zu dem Hauptanwendungscode verwendet, wie z.B. `frontend/dist`:

```go title="main.go"
//go:embed all:frontend/dist
var assets embed.FS
```

Beim Start wird Wails die Embedded Dateien iterieren und nach dem Verzeichnis suchen, das `index.html` enthält. Alle anderen Assets werden relativ zu diesem Verzeichnis geladen.

Da Produktionsbinärdateien die in `embed.FS` enthaltenen Dateien verwenden, gibt es keine externen Dateien, die mit der Anwendung ausgeliefert werden müssen.

Beim Ausführen der Anwendung im Entwicklungsmodus, mit dem `wails dev` Befehl, werden die Assets von der Festplatte geladen, und alle Änderungen werden mit einem "live Reload" zur Verfügung gestellt. Der Standort der Assets wird vom `embed.FS` abgeleitet.

Weitere Details in der [Anwendungs-Entwicklungs Anleitung](guides/application-development.mdx).

#### Anwendungslaufzeit Callbacks

Kurz bevor das Frontend `index.html` lädt, wird ein Callback an die Funktion getätigt, die in [OnStartup](reference/options.mdx#onstartup) bereitgestellt wurde. Ein Standard-Go-Kontext wird an diese Methode übergeben. Dieser Kontext wird benötigt, wenn die Laufzeit aufgerufen wird, sodass ein Standardmuster eine Referenz in dieser Methode speichert. Kurz bevor die Anwendung herunterfährt, wird der [OnShutdown](reference/options.mdx#onshutdown) Callback auf die gleiche Art und Weise aufgerufen, erneut mit dem Kontext. Es gibt auch einen [OnDomReady](reference/options.mdx#ondomready) Rückruf für den Fall, dass das Frontend alle Assets in `Index.html` geladen hat, dieser ist gleichwertig mit dem [`body onload`](https://www.w3schools.com/jsref/event_onload.asp) Ereignis in JavaScript. Es ist auch möglich, das Schließen (oder Beenden von Anwendungen) des Fensters mit der Option [OnBeforeClose](reference/options.mdx#onbeforeclose) zu verknüpfen.

#### Methodenverknüpfung

Die `Bind` Option ist eine der wichtigsten Optionen in einer Wails Anwendung. Diese legt fest, welche struct Methoden zur Verwendung im Frontend zur Verfügung stehen sollen. Structs sind ähnlich zu Kontrollern einer traditionellen Webanwendung. Wenn die Anwendung startet, prüft sie die im Feld `Bind` aufgelisteten struct Instanzen, in den Optionen und bestimmt, welche Methoden öffentlich sind (beginnend mit einem Großbuchstaben) und erzeugt JavaScript-Versionen der Methoden, die im Frontend-Code aufgerufen werden können.

:info Notiz

Wails erfordert, dass du in eine _Instanz_ des structs weitergibst, damit es korrekt verknüpft werden kann

:::

In diesem Beispiel erstellen wir eine neue `App` Instanz und fügen diese Instanz der `Bind` Option in `wails.Run` hinzu:

```go {17,27} title="main.go"
package main

import (
    "embed"
    "log"

    "github.com/wailsapp/wails/v2"
    "github.com/wailsapp/wails/v2/pkg/options"
  "github.com/wailsapp/wails/v2/pkg/options/assetserver"
)

//go:embed all:frontend/dist
var assets embed.FS

func main() {

    app := &App{}

    err := wails.Run(&options.App{
        Title:  "Basic Demo",
        Width:  1024,
        Height: 768,
        AssetServer: &assetserver.Options{
            Assets: assets,
        },
        Bind: []interface{}{
            app,
        },
    })
    if err != nil {
        log.Fatal(err)
    }
}


type App struct {
    ctx context.Context
}

func (a *App) Greet(name string) string {
    return fmt.Sprintf("Hello %s!", name)
}
```

Es können so viele structs verknüpft werden, wie benötigt werden. Stelle sicher, dass eine Instanz erstellt wurde und in `Bind` verknüpft wurde:

```go {10-12}
    //...
    err := wails.Run(&options.App{
        Title:  "Basic Demo",
        Width:  1024,
        Height: 768,
        AssetServer: &assetserver.Options{
            Assets: assets,
        },
        Bind: []interface{}{
            app,
            &mystruct1{},
            &mystruct2{},
        },
    })

```

Enum-Typen können auch verknüpft werden. In diesem Fall sollte ein Array erstellt werden, das alle möglichen Enum-Werte enthält. Verknüpfe das Enum mit der App über `EnumBind`:

```go {16-18} title="app.go"
type Weekday string

const (
    Sunday    Weekday = "Sunday"
    Monday    Weekday = "Monday"
    Tuesday   Weekday = "Tuesday"
    Wednesday Weekday = "Wednesday"
    Thursday  Weekday = "Thursday"
    Friday    Weekday = "Friday"
    Saturday  Weekday = "Saturday"
)

var AllWeekdays = []struct {
    Value  Weekday
    TSName string
}{
    {Sunday, "SUNDAY"},
    {Monday, "MONDAY"},
    {Tuesday, "TUESDAY"},
    {Wednesday, "WEDNESDAY"},
    {Thursday, "THURSDAY"},
    {Friday, "FRIDAY"},
    {Saturday, "SATURDAY"},
}
```

```go {10-12}
    //...
    err := wails.Run(&options.App{
        Title:  "Basic Demo",
        Width:  1024,
        Height: 768,
        AssetServer: &assetserver.Options{
            Assets: assets,
        },
        Bind: []interface{}{
            app,
            &mystruct1{},
            &mystruct2{},
        },
    EnumBind: []interface{}{
        AllWeekdays,
    },
    })

```

Wenn `wails dev` (oder `wails gemerate module`) aufgeführt wird, wird ein Frontend-Modul generiert, das Folgendes enthält:

- JavaScript-Verknüpfungen für alle verknüpften Methoden
- TypeScript Deklarationen für alle verknüpften Methoden
- TypeScript Definitionen für alle Go-Structs, die als Eingaben oder Ausgaben der verknüpften Methoden verwendet werden

Das macht es unglaublich einfach, Go-Code vom Frontend aus aufzurufen, wobei die gleichen Datenrukturen verwendet werden.

## Das Frontend

### Übersicht

Das Frontend ist eine Sammlung von Dateien, die von Webkit gerendert werden. Es ist wie ein Browser und Webserver in einem. Es gibt praktisch[^1] kein Limit für welche Frameworks oder Bibliotheken es verwendet werden soll. Die wichtigsten Punkte der Interaktion zwischen Frontend und deinem Go-Code sind:

- Aufrufen von verknüpften Go-Methoden
- Aufrufen von Laufzeit-Methoden

### Aufrufen von verknüpften Go-Methoden

Wenn die Anwendung nach der Ausführung von `wails dev` läuft, werden automatisch JavaScript-Verknüpfungen für structs im Verzeichnis namens `wailsjs/go` generiert (Es kann ebenfalls manuell mit dem Befehl `wails generate module` erledigt werden). Die generierten Dateien spiegeln die Paketnamen in der Anwendung wider. Im obigen Beispiel verknüpfen wir `app`, die eine öffentliche Methode namens `Greet` hat. Das führt zur Generierung der folgenden Dateien:

```bash
wailsjs
  └─go
    └─main
      ├─App.d.ts
      └─App.js
```

Hier können wir sehen, dass es ein `main` package gibt, das die JavaScript-Verknüpfungen für die verknüpften `App` Structs enthält, sowie auch TypeScript Deklarationsdateien für ihre Methoden. Um `Greet` von unserem Frontend aufzurufen, importieren wir einfach die Methode und rufen sie wie eine normale JavaScript-Funktion auf:

```javascript
// ...
import { Greet } from "../wailsjs/go/main/App";

function doGreeting(name) {
  Greet(name).then((result) => {
    // Do something with result
  });
}
```

Die TypeScript-Deklarationsdatei gibt die richtigen Typen für die verknüpften Methoden:

```ts
export function Greet(arg1: string): Promise<string>;
```

Die erzeugten Methoden geben ein Promise zurück. Ein erfolgreicher Aufruf führt dazu, dass der erste Rückgabewert des Go-Aufrufs an den `resolve`-Handler übergeben wird. Ein fehlgeschlagener Aufruf entsteht, wenn eine Go-Methode, die als zweiten Rückgabewert einen Fehlertyp hat eine Fehlerinstanz an den Aufrufer zurückgibt. Das wird über den `reject` Handler zurückgegeben. Im obigen Beispiel `Greet` wird nur ein `String` zurückgeben, sodass der JavaScript-Aufruf nie zurückgewiesen werden kann - es sei denn, es werden ungültige Daten übergeben.

Alle Datentypen werden zwischen Go und JavaScript korrekt übersetzt. Selbst structs. Wenn du in einem Go-Aufruf ein struct zurückgibst, wird dieser als JavaScript-Klasse an dein Frontend zurückgeschickt.

:info Notiz

Struct felder _müssen_ einen gültigen `json` Tag besitzen, um in den generierten TypeScript code aufgenommen zu werden.

Anonyme, verschachtelte structs werden derzeit nicht unterstützt.

:::

Es ist möglich, structs zurück zu Go zu senden. Jede JavaScript-Map/Klasse, die als Argument übergeben wird und ein struct erwartet, wird in diesen struct-Typ konvertiert. Um diesen Prozess einfacher zu machen, wird im `dev` Modus ein TypeScript-Modul generiert, das alle struct Typen definiert, die in verknüpften Methoden verwendet werden. Mithilfe dieses Moduls können native JavaScript-Objekte erstellt werden und an den Go-Code versendet werden.

Es gibt auch Unterstützung für Go-Methoden, die structs in ihrer signature beinhalten. Bei allen Go-Anweisungen, die durch eine verknüpfte Methode (entweder als Parameter oder als Rückgabetypen) angegeben werden, werden TypeScript Versionen automatisch als Teil des Go-Code-Wrapper Moduls generiert. Mit diesem Datenmodell ist es möglich, die gleichen Daten zwischen Go und JavaScript zu teilen.

Beispiel: Wir aktualisieren unsere `Greet` Methode, um eine `Person` statt eines strings zu akzeptieren:

```go title="main.go"
type Person struct {
    Name string `json:"name"`
    Age uint8 `json:"age"`
    Address *Address `json:"address"`
}

type Address struct {
    Street string `json:"street"`
    Postcode string `json:"postcode"`
}

func (a *App) Greet(p Person) string {
    return fmt.Sprintf("Hello %s (Age: %d)!", p.Name, p.Age)
}
```

Die `wailsjs/go/main/App.js` Datei hat immer noch den folgenden Code:

```js title="App.js"
export function Greet(arg1) {
  return window["go"]["main"]["App"]["Greet"](arg1);
}
```

Aber die `wailsjs/go/main/App.d.ts` Datei wird mit folgendem Code aktualisiert:

```ts title="App.d.ts"
import { main } from "../models";

export function Greet(arg1: main.Person): Promise<string>;
```

Wie wir sehen können, wird der "main"-Namensraum aus einer neuen "models.ts"-Datei importiert. Diese Datei enthält alle struct Definitionen, die von unseren verknüpften Methoden verwendet werden. In diesem Beispiel ist dies ein `Person` struct. Wenn wir uns `models.ts` anschauen, können wir sehen, wie die Modelle definiert sind:

```ts title="models.ts"
export namespace main {
  export class Address {
    street: string;
    postcode: string;

    static createFrom(source: any = {}) {
      return new Address(source);
    }

    constructor(source: any = {}) {
      if ("string" === typeof source) source = JSON.parse(source);
      this.street = source["street"];
      this.postcode = source["postcode"];
    }
  }
  export class Person {
    name: string;
    age: number;
    address?: Address;

    static createFrom(source: any = {}) {
      return new Person(source);
    }

    constructor(source: any = {}) {
      if ("string" === typeof source) source = JSON.parse(source);
      this.name = source["name"];
      this.age = source["age"];
      this.address = this.convertValues(source["address"], Address);
    }

    convertValues(a: any, classs: any, asMap: boolean = false): any {
      if (!a) {
        return a;
      }
      if (a.slice && a.map) {
        return (a as any[]).map((elem) => this.convertValues(elem, classs));
      } else if ("object" === typeof a) {
        if (asMap) {
          for (const key of Object.keys(a)) {
            a[key] = new classs(a[key]);
          }
          return a;
        }
        return new classs(a);
      }
      return a;
    }
  }
}
```

Solange TypeScript Teil der Frontend-Build-Konfiguration ist, können diese Modelle wie folgt verwenden:

```js title="mycode.js"
import { Greet } from "../wailsjs/go/main/App";
import { main } from "../wailsjs/go/models";

function generate() {
  let person = new main.Person();
  person.name = "Peter";
  person.age = 27;
  Greet(person).then((result) => {
    console.log(result);
  });
}
```

Die Kombination aus generierten Verknüpfungen und TypeScript-Modellen sorgt für eine leistungsstarke Entwicklungsumgebung.

Weitere Informationen zu Verknüpfungen sind im [Verknüpfungs methoden](guides/application-development.mdx#binding-methods) Abschnitt der [Anwendungs-Entwicklungs-Anleitungen](guides/application-development.mdx) zu finden.

### Aufrufen von Laufzeit-Methoden

Die JavaScript-Laufzeit befindet sich in `window.runtime` und enthält viele Methoden, um verschiedene Aufgaben zu erledigen, wie zum Beispiel ein Event aufzurufen oder Logging durchführen:

```js title="mycode.js"
window.runtime.EventsEmit("my-event", 1);
```

Weitere Details zur JS-Laufzeit in der [Laufzeitreferenz](reference/runtime/intro.mdx).

[^1]: Es gibt eine sehr kleine Teilmenge von Bibliotheken, die Funktionen verwenden, die in einem WebView nicht unterstützt werden. Es gibt häufig Alternativen und Workarounds für solche Fälle.
