# Codesignatur

Dies ist eine Anleitung, wie du deine mit Wails auf MacOS und Windows generierten Binärdateien signieren kannst. Die Anleitung wird CI-Umgebungen ins Visier nehmen, genauer gesagt GitHub Actions.

## Windows

Als erstes benötigst du ein Zertifikat zur Codesignierung. Wenn du noch kein Zertifikat hast, listet Microsofts Infoseite einige Anbieter [hier](https://docs.microsoft.com/en-us/windows-hardware/drivers/dashboard/get-a-code-signing-certificate) auf. Bitte beachte, dass ein EV-Zertifikat nicht erforderlich ist, es sei denn, du musst kernel-level Software wie Gerätetreiber schreiben. Zum Signieren deiner Wails App reicht ein normales Code-Signaturzertifikat aus.

Es empfiehlt sich, vor der Verwendung automatisierter Build-Systeme mit deinem Zertifikatsanbieter zu prüfen, wie du deine Binärdateien auf deinem lokalen Rechner signierst, um eventuelle Besonderheiten zu kennen. Zum Beispiel ist [hier](https://www.ssl.com/how-to/using-your-code-signing-certificate/) die Anleitung von SSL.com zum Signieren von Code für Windows. Wenn du lokal signieren kannst, wird es einfacher sein, mögliche Probleme in einer CI-Umgebung zu beheben. Zum Beispiel benötigen SSL.com Code-Signing-Zertifikate die `/tr`-Flagge für [SignTool.exe](https://docs.microsoft.com/en-us/windows/win32/seccrypto/signtool), während andere Anbieter möglicherweise nur die `/t`-Flagge für den timestamping-Server benötigen. Beliebte GitHub Actions zum Signieren von Windows-Binärdateien wie [diese hier](https://github.com/Dana-Prajea/code-sign-action) unterstützen die `/tr`-Flagge in SignTool.exe nicht. Daher konzentriert sich diese Anleitung darauf, unsere App manuell mit PowerShell-Befehlen zu signieren, aber du kannst auch Aktionen wie die [code-sign-action](https://github.com/Dana-Prajea/code-sign-action) Aktion verwenden, wenn du diese vorziehst.

Zuerst stellen wir sicher, dass wir unsere Wails App in unserem GitHub CI builden können. Hier ist eine kleine Workflow-Vorlage:

```yaml
name: "example"
on:
  workflow_dispatch:
    # This Action only starts when you go to Actions and manually run the workflow.

jobs:
  package:
    strategy:
      matrix:
        platform: [windows-latest, macos-latest]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v3
      - name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: ${{ matrix.go-version }}
      - name: setup node
        uses: actions/setup-node@v2
        with:
          node-version: 14
      # Möglicherweise muss hier dein Frontend manuell erstellt werden, es sei denn, du hast Build- und Installationsbefehle für das Frontend in wails.json konfiguriert.
      - name: Get Wails
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest
      - name: Build Wails app
        run: |
          wails build
      - name: upload artifacts macOS
        if: matrix.platform == 'macos-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-macos
          path: build/bin/*
      - name: upload artifacts windows
        if: matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-windows
          path: build/bin/*
```

Als nächstes müssen wir dem GitHub Workflow Zugriff auf unser Signaturzertifikat geben. Dies geschieht, indem du dein .pfx- oder .p12-Zertifikat in einen base64-String kodierest. Um dies in PowerShell zu tun, kannst du den folgenden Befehl verwenden, vorausgesetzt dein Zertifikat heißt 'my-cert.p12':

```PowerShell
certutil -encode .\my-cert.p12 my-cert-base64.txt
```

Du solltest nun deine .txt-Datei mit dem base64-kodierten Zertifikat haben. Es sollte mit _----BEGIN ZERTIFICATE-----_ beginnen und mit _-----END ZERTIFICATE-----_ enden. Nun musst du auf GitHub zwei action secrets erstellen. Navigiere zu den _Settings-> Secrets-> Actions_ und erstelle die zwei folgende Geheimnisse:

- **WIN_SIGNING_CERT** mit dem Inhalt deines base64 kodierten Zertifikatstextes.
- **WIN_SIGNING_CERT_PASSWORD** mit dem Inhalt deines Zertifikatspassworts.

Jetzt sind wir bereit, die Anmeldung in unserem Workflow mit einer der beiden Methoden zu implementieren:

### Methode 1: mit Befehlen signieren

Diese Methode benutzt PowerShell Befehle, um unsere App zu signieren und überlässt dir die Kontrolle über den gesamten Signaturprozess.

Nach dem `"Build Wails App"` Schritt können wir folgenden Schritt zu unserem Workflow hinzufügen:

```yaml
- name: Sign Windows binaries
    if: matrix.platform == 'windows-latest'
    run: |
        echo "Creating certificate file"
        New-Item -ItemType directory -Path certificate
        Set-Content -Path certificate\certificate.txt -Value '${{ secrets.WIN_SIGNING_CERT }}'
        certutil -decode certificate\certificate.txt certificate\certificate.pfx
        echo "Signing our binaries"
        & 'C:/Program Files (x86)/Windows Kits/10/bin/10.0.17763.0/x86/signtool.exe' sign /fd <signing algorithm> /t <timestamping server> /f certificate\certificate.pfx /p '${{ secrets.WIN_SIGNING_CERT_PASSWORD }}' <path to binary>

```

Dieses Skript erstellt ein neues Verzeichnis für deine Zertifikatsdatei, erstellt die Zertifikatsdatei aus unserem base64 secret, konvertiert sie in eine .fx-Datei, und signiert schließlich die Binärdatei. Die folgenden Variablen müssen in der letzten Zeile ersetzt werden:

- **signing algorithm**: Normalerweise sha256.
- **timestamping server**: URL zum Timestamping-Server für dein Zertifikat.
- **path to binary**: Pfad zur Binärdatei die du signieren möchtest.

Da unsere Wails Konfiguration `outputfilename` auf "app.exe" gesetzt hat und wir ein Zertifikat von SSL.com haben, wäre dies unser Workflow:

```yaml
name: "example"
on:
  workflow_dispatch:
    # This Action only starts when you go to Actions and manually run the workflow.

jobs:
  package:
    strategy:
      matrix:
        platform: [windows-latest, macos-latest]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v3
      - name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: ${{ matrix.go-version }}
      - name: setup node
        uses: actions/setup-node@v2
        with:
          node-version: 14
      # You may need to manually build you frontend here, unless you have configured frontend build and install commands in wails.json.
      - name: Get Wails
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest
      - name: Build Wails app
        run: |
          wails build
      - name: Sign Windows binaries
        if: matrix.platform == 'windows-latest'
        run: |
          echo "Creating certificate file"
          New-Item -ItemType directory -Path certificate
          Set-Content -Path certificate\certificate.txt -Value '${{ secrets.WIN_SIGNING_CERT }}'
          certutil -decode certificate\certificate.txt certificate\certificate.pfx
          echo "Signing our binaries"
          & 'C:/Program Files (x86)/Windows Kits/10/bin/10.0.17763.0/x86/signtool.exe' sign /fd sha256 /tr http://ts.ssl.com /f certificate\certificate.pfx /p '${{ secrets.WIN_SIGNING_CERT_PASSWORD }}' .\build\bin\app.exe

      - name: upload artifacts macOS
        if: matrix.platform == 'macos-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-macos
          path: build/bin/*
      - name: upload artifacts windows
        if: matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-windows
          path: build/bin/*
```

### Methode 2: Automatisch mit Action signieren

Es ist möglich, eine Windows-Code Signierungsaktion wie [diese](https://github.com/marketplace/actions/code-sign-a-file-with-pfx-certificate) zu verwenden aber beachte, dass es einen SHA1-Hash für das Zertifikat und einen Zertifikatsnamen benötigt. Schau dir ein Beispiel auf dem [Marketplace](https://github.com/marketplace/actions/code-sign-a-file-with-pfx-certificate) an, wie du es konfigurieren kannst.

---

## MacOS

Als erstes benötigst du dein Zertifikat zur Codesignierung von Apple. Wenn du noch keins haben solltest, kannst du dir mit einer einfachen Google-Suche eine zulegen. Sobald du dein Zertifikat hast, musst du es exportieren und in base64 kodieren. [Dieses Tutorial](https://localazy.com/blog/how-to-automatically-sign-macos-apps-using-github-actions) zeigt dir, wie du das auf eine einfache Weise tun kannst. Sobald du deine .p12-Zertifikatsdatei exportiert hast, kannst du diese in base64 kodieren, wie im Tutorial zu sehen ist, mit folgendem Befehl:

```bash
base64 Certificates.p12 | pbcopy
```

Jetzt kannst du einige GitHub Projekt-Secrets erstellen, genau wie bei Windows:

- **APPLE_DEVELOPER_CERTIFICATE_P12_BASE64** mit dem Inhalt deines neu kopierten base64-Zertifikats.
- **APPLE_DEVELOPER_CERTIFICATE_PASSWORD** mit dem Inhalt deines Zertifikatspassworts.
- **APPLE_PASSWORD** mit dem Inhalt eines app-spezifischen Passworts für dein Apple-ID-Konto, das du [hier](https://appleid.apple.com/account/manage) generieren kannst.

Stellen wir sicher, dass wir in der Lage sind, unsere Wails App in unserem GitHub Action Workflow zu bauen. Hier ist eine kleine Vorlage:

```yaml
name: "example"
on:
  workflow_dispatch:
    # This Action only starts when you go to Actions and manually run the workflow.

jobs:
  package:
    strategy:
      matrix:
        platform: [windows-latest, macos-latest]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v3
      - name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: ${{ matrix.go-version }}
      - name: setup node
        uses: actions/setup-node@v2
        with:
          node-version: 14
      # You may need to manually build you frontend here, unless you have configured frontend build and install commands in wails.json.
      - name: Get Wails
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest
      - name: Build Wails app
        run: |
          wails build
      - name: upload artifacts macOS
        if: matrix.platform == 'macos-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-macos
          path: build/bin/*
      - name: upload artifacts windows
        if: matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-windows
          path: build/bin/*
```

Für die Code-Signierung auf macOS ist [gon](https://github.com/Bearer/gon) ein sehr praktisches Werkzeug zur Codesignierung und Kommunikation mit Apple-Servern, ebenfalls in Go geschrieben, und wird in dieser Anleitung verwendet.

Nach dem `Build Wails App` Schritt können wir folgendes zum Workflow hinzufügen:

```yaml
- name: MacOS download gon for code signing and app notarization
  if: matrix.platform == 'macos-latest'
  run: |
    brew install Bearer/tap/gon
```

Nun müssen wir einige gon Konfigurationsdateien in unserem `build/darwin` Verzeichnis konfigurieren:

1. gon-sign.json:

```json
{
  "source": ["./build/bin/app.app"],
  "bundle_id": "app.myapp",
  "apple_id": {
    "username": "my-appleid@email.com",
    "password": "your-app-specific-password",
    "provider": "ABCDE12345"
  },
  "sign": {
    "application_identity": "Developer ID Application: Human User"
  }
}
```

Hier ist eine kurze Erklärung der obigen Felder:

- `source`: Der Ort der zu signierenden Wails Binärdatei
- `apple_id`:
  - `username`: Deine Apple-ID E-Mail-Adresse
  - `password`: Dein app-spezifisches Passwort
  - `provider`: Deine Team-ID für dein App Store Connect Konto
- `sign`:
  - `application_identity`: Deine Apple Entwickler Identität

Die Syntax von (https://developer.apple.com/documentation/technotes/tn3147-migrating-to-the-latest-notarization-tool)[veraltetes Apple-Tool], die `@env:` unterstützt, ist nicht mehr verfügbar, da Apple auf das neue Notary-Tool umgestellt hat.

Deine Entwickleridentität und Team-ID können beide auf macOS gefunden werden, indem du den folgenden Befehl ausführst:

```bash
$ security find-identity -v -p codesigning
  1) 00000000000000000000000000000000000000000 "Developer ID Application: Human User (ABCDE12345)"
```

2. entitlements.plist:

```plist
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>com.apple.security.app-sandbox</key>
  <true/>
  <key>com.apple.security.network.client</key>
  <true/>
  <key>com.apple.security.network.server</key>
  <true/>
  <key>com.apple.security.files.user-selected.read-write</key>
  <true/>
  <key>com.apple.security.files.downloads.read-write</key>
  <true/>
</dict>
</plist>
```

In dieser Datei konfigurierst du die Berechtigungen, die du für deine App benötigst, z.B. Kamera-Berechtigungen, wenn deine App die Kamera verwendet. Lese mehr über die Berechtigungen [hier](https://developer.apple.com/documentation/bundleresources/entitlements).

Stelle sicher, dass du deine `Info.plist` Datei mit der gleichen Bundle-ID wie die in der `gon-sign.json` eingegeben haben. Hier ist eine Beispiel `Info.plist` Datei:

```plist
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0"><dict>
    <key>CFBundlePackageType</key><string>APPL</string>
    <key>CFBundleName</key><string>MyApp</string>
    <key>CFBundleExecutable</key><string>app</string>
    <key>CFBundleIdentifier</key><string>app.myapp</string>
    <key>CFBundleVersion</key><string>0.1.0</string>
    <key>CFBundleGetInfoString</key><string>My app is cool and nice and chill and</string>
    <key>CFBundleShortVersionString</key><string>0.1.0</string>
    <key>CFBundleIconFile</key><string>iconfile</string>
    <key>LSMinimumSystemVersion</key><string>10.13.0</string>
    <key>NSHighResolutionCapable</key><string>true</string>
    <key>LSApplicationCategoryType</key><string>public.app-category.utilities</string>
    <key>NSHumanReadableCopyright</key><string>© Me</string>
</dict></plist>
```

Jetzt sind wir bereit, nach dem Erstellen der Wails App den Signaturschritt in unserem Workflow hinzuzufügen:

```yaml
- name: Import Code-Signing Certificates for macOS
  if: matrix.platform == 'macos-latest'
  uses: Apple-Actions/import-codesign-certs@v1
  with:
    # The certificates in a PKCS12 file encoded as a base64 string
    p12-file-base64: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_P12_BASE64 }}
    # The password used to import the PKCS12 file.
    p12-password: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}
- name: Sign our macOS binary
  if: matrix.platform == 'macos-latest'
  run: |
    echo "Signing Package"
    gon -log-level=info ./build/darwin/gon-sign.json
```

Bitte beachte, dass die Signierung von Binärdateien mit Apple von Minuten zu Stunden dauern kann.

## Kombinierte Workflowdatei:

Hier ist unsere GitHub Workflow-Datei mit Windows + macOS kombiniert:

```yaml
name: "example combined"
on:
  workflow_dispatch:
  # This Action only starts when you go to Actions and manually run the workflow.

jobs:
  package:
    strategy:
      matrix:
        platform: [windows-latest, macos-latest]
        go-version: [1.18]
    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v3
      - name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: ${{ matrix.go-version }}
      - name: setup node
        uses: actions/setup-node@v2
        with:
          node-version: 14
      # You may need to manually build you frontend here, unless you have configured frontend build and install commands in wails.json.
      - name: Get Wails
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest
      - name: Build Wails app
        run: |
          wails build
      - name: MacOS download gon for code signing and app notarization
        if: matrix.platform == 'macos-latest'
        run: |
          brew install Bearer/tap/gon
      - name: Import Code-Signing Certificates for macOS
        if: matrix.platform == 'macos-latest'
        uses: Apple-Actions/import-codesign-certs@v1
        with:
          # The certificates in a PKCS12 file encoded as a base64 string
          p12-file-base64: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_P12_BASE64 }}
          # The password used to import the PKCS12 file.
          p12-password: ${{ secrets.APPLE_DEVELOPER_CERTIFICATE_PASSWORD }}
      - name: Sign our macOS binary
        if: matrix.platform == 'macos-latest'
        run: |
          echo "Signing Package"
          gon -log-level=info ./build/darwin/gon-sign.json
      - name: Sign Windows binaries
        if: matrix.platform == 'windows-latest'
        run: |
          echo "Creating certificate file"
          New-Item -ItemType directory -Path certificate
          Set-Content -Path certificate\certificate.txt -Value '${{ secrets.WIN_SIGNING_CERT }}'
          certutil -decode certificate\certificate.txt certificate\certificate.pfx
          echo "Signing our binaries"
          & 'C:/Program Files (x86)/Windows Kits/10/bin/10.0.17763.0/x86/signtool.exe' sign /fd sha256 /tr http://ts.ssl.com /f certificate\certificate.pfx /p '${{ secrets.WIN_SIGNING_CERT_PASSWORD }}' .\build\bin\Monitor.exe
      - name: upload artifacts macOS
        if: matrix.platform == 'macos-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-macos
          path: build/bin/*
      - name: upload artifacts windows
        if: matrix.platform == 'windows-latest'
        uses: actions/upload-artifact@v2
        with:
          name: wails-binaries-windows
          path: build/bin/*
```

# Schluss Worte

Diese Anleitung ist vom RiftShare-Projekt und seinem Workflow inspiriert, der dringend empfohlen wird, [hier](https://github.com/achhabra2/riftshare/blob/main/.github/workflows/build.yaml) zu besuchen.
