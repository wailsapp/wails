# Entwicklung von Anwendungen

Es gibt keine festen Regeln für die Entwicklung von Anwendungen mit Wails, aber einige grundlegende Richtlinien.

## Anwendungseinrichtung

Das von den Standardvorlagen verwendete Muster ist, dass `main.go` zum Konfigurieren und Ausführen der Anwendung verwendet wird, während `app.go` zur Definition der Anwendungslogik verwendet wird.

Die `app.go` Datei definiert einen Struct mit 2 Methoden, die als Hooks in der Hauptanwendung fungieren:

```go title="app.go"
type App struct {
    ctx context.Context
}

func NewApp() *App {
    return &App{}
}

func (a *App) startup(ctx context.Context) {
    a.ctx = ctx
}

func (a *App) shutdown(ctx context.Context) {
}
```

- Die startup Methode wird aufgerufen, sobald Wails die benötigten Ressourcen angefordert hat und ist ein guter Ort für die Erstellung von eigenen Ressourcen sowie die Konfigurierung von Events und alles andere, was die Anwendung beim Start braucht. Es wird ein `context.Context` übergeben, der normalerweise in einem Struct-Feld gespeichert wird. Dieser Kontext wird benötigt, um die [Laufzeit](../reference/runtime/intro.mdx) aufzurufen. Gibt diese Methode einen Fehler zurück, wird die Anwendung beendet. Im Dev-Modus wird der Fehler in die Konsole ausgegeben.

- Die shutdown Methode wird von Wails direkt am Ende des Shutdown-Prozesses aufgerufen. Dies ist ein guter Ort, um Ressourcen wieder freizugeben und um alle anderen Aufgaben zu beenden.

Die `main.go` Datei besteht im Allgemeinen aus einem einzigen Aufruf von `wails.Run()`, der die Anwendungskonfiguration akzeptiert. Das Muster, das in den Vorlagen verwendet wird, besteht darin, dass vor dem Aufruf von `wails.Run()` eine Instanz des Structs, die wir in `app.go` definiert haben, erstellt und in einer Variable namens `app` gespeichert wird. Diese Konfiguration ist der Ort, an dem wir unsere Callbacks hinzufügen:

```go {3,9,10} title="main.go"
func main() {

    app := NewApp()

    err := wails.Run(&options.App{
        Title:             "My App",
        Width:             800,
        Height:            600,
        OnStartup:  app.startup,
        OnShutdown: app.shutdown,
    })
    if err != nil {
        log.Fatal(err)
    }
}

```

Weitere Informationen zu Anwendungslaufzeit hooks sind [hier](../howdoesitwork.mdx#application-lifecycle-callbacks) zu finden.

## Methoden Verknüpfen

Es ist wahrscheinlich, dass Go-Methoden vom Frontend aufgerufen werden sollen. Normalerweise wird das durch das Hinzufügen öffentlicher Methoden zu den bereits definierten structs in `app.go` gemacht:

```go {16-18} title="app.go"
type App struct {
    ctx context.Context
}

func NewApp() *App {
    return &App{}
}

func (a *App) startup(ctx context.Context) {
    a.ctx = ctx
}

func (a *App) shutdown(ctx context.Context) {
}

func (a *App) Greet(name string) string {
    return fmt.Sprintf("Hello %s!", name)
}
```

In der Hauptanwendungskonfiguration ist der `Bind` Key, der, bei dem wir Wails sagen können, was wir verknüpfen wollen:

```go {11-13} title="main.go"
func main() {

    app := NewApp()

    err := wails.Run(&options.App{
        Title:             "My App",
        Width:             800,
        Height:            600,
        OnStartup:  app.startup,
        OnShutdown: app.shutdown,
        Bind: []interface{}{
            app,
        },
    })
    if err != nil {
        log.Fatal(err)
    }
}

```

Das wird alle öffentlichen Methoden in unserem `App` struct verknüpfen (ausgenommen davon sind die Start- und Herunterfahrmethoden).

### Umgang mit dem Kontext, wenn mehrere structs verknüpft werden

Solltest du mehrmals den Anwendungskontext in verschiedenen Structs referenzieren wollen, ist es sinnvoll, das in der `OnStartup` Methode zu machen:

```go
func main() {

    app := NewApp()
    otherStruct := NewOtherStruct()

    err := wails.Run(&options.App{
        Title:             "My App",
        Width:             800,
        Height:            600,
        OnStartup:  func(ctx context.Context){
            app.SetContext(ctx)
            otherStruct.SetContext(ctx)
        },
        OnShutdown: app.shutdown,
        Bind: []interface{}{
            app,
            otherStruct
        },
    })
    if err != nil {
        log.Fatal(err)
    }
}
```

Auch Enums können in Structs verwendet werden, diese erhalten im Frontend entsprechende Modelle. In diesem Fall sollte ein Array erstellt werden, das alle möglichen Enum-Werte enthält:

```go {16-18} title="app.go"
type Weekday string

const (
    Sunday    Weekday = "Sunday"
    Monday    Weekday = "Monday"
    Tuesday   Weekday = "Tuesday"
    Wednesday Weekday = "Wednesday"
    Thursday  Weekday = "Thursday"
    Friday    Weekday = "Friday"
    Saturday  Weekday = "Saturday"
)

var AllWeekdays = []struct {
    Value  Weekday
    TSName string
}{
    {Sunday, "SUNDAY"},
    {Monday, "MONDAY"},
    {Tuesday, "TUESDAY"},
    {Wednesday, "WEDNESDAY"},
    {Thursday, "THURSDAY"},
    {Friday, "FRIDAY"},
    {Saturday, "SATURDAY"},
}
```

In der Hauptanwendungskonfiguration ist der `EnumBind` Key, der, bei dem wir Wails sagen können, welche Emums wir verknüpfen wollen:

```go {11-13} title="main.go"
func main() {

    app := NewApp()

    err := wails.Run(&options.App{
        Title:             "My App",
        Width:             800,
        Height:            600,
        OnStartup:  app.startup,
        OnShutdown: app.shutdown,
    Bind: []interface{}{
        app,
    },
    EnumBind: []interface{}{
        AllWeekdays,
     },
    })
    if err != nil {
        log.Fatal(err)
    }
}

```

Dadurch werden fehlende Enums zu der `model.ts` Datei hinzugefügt.

Weitere Informationen dazu [hier](../howdoesitwork.mdx#method-binding).

## Anwendungsmenü

Wails unterstützt das Hinzufügen eines Menüs zur Anwendung. Das geschieht durch die Übergabe eines [Menu](../reference/menus.mdx#menu)-Structs an die Anwendungskonfiguration. Es ist üblich, eine Methode zu verwenden, die ein Menü zurückgibt, vorzugsweise eine Methode im `App` struct, die für die Laufzeit Hooks verwendet wird.

```go {11} title="main.go"
func main() {

    app := NewApp()

    err := wails.Run(&options.App{
        Title:             "My App",
        Width:             800,
        Height:            600,
        OnStartup:  app.startup,
        OnShutdown: app.shutdown,
        Menu:       app.menu(),
        Bind: []interface{}{
            app,
        },
    })
    if err != nil {
        log.Fatal(err)
    }
}

```

## Assets

Das Großartige an der Art und Weise, wie Wails v2 mit Assets umgeht, ist, dass es das nicht tut! Das Einzige, was Wails benötigt, ist `embed.FS`. Wie ein embed.FS erzeugt wird, ist dir überlassen. Du kannst Vanilla html/css/js Dateien wie das Vanilla Template verwenden. Oder auch ein kompliziertes Build-System, es spielt keine Rolle.

Wenn `wails build` ausführt wird, wird die `wails.json` Projektdatei im Projektverzeichnis überprüft. Es gibt 2 Schlüssel in der Projektdatei, die gelesen werden:

- "frontend:install"
- "frontend:build"

Der erste, falls angegeben, wird im `Frontend` Verzeichnis ausgeführt, um die node Modules zu installieren. Der zweite, falls angegeben, wird im `frontend`-Verzeichnis ausgeführt, um das Frontend-Projekt zu erstellen.

Wenn diese 2 Keys nicht gegeben werden, dann tut Wails absolut nichts mit dem Frontend. Es wird nur erwartet, dass `embed.FS` vorhanden ist.

### AssetsHandler

Eine Wails v2 App kann optional einen `http.Handler` in den `options.App` definieren, der das Hooking in den AssetServer erlaubt, um Dateien zu erstellen oder POST/PUT-Anfragen zu verarbeiten. GET-Anfragen werden immer zuerst vom `assets` FS bearbeitet. Wenn der FS die angeforderte Datei nicht findet, wird die Anfrage an den `http.Handler` weitergeleitet, um diese zu verarbeiten. Alle anderen Anfragen als GET werden direkt vom `AssetsHandler` bearbeitet, sofern angegeben. Es ist auch möglich, nur den `AssetsHandler` zu verwenden, indem `nil` als `Assets` Option angegeben wird.

## Eingebauter Dev Server

Das Ausführen von `wails dev` startet den eingebauten Entwicklungsserver, der einen Dateibeobachter im Projektverzeichnis startet. Standardmäßig prüft wails bei Änderungen an Dateien, ob es sich um eine Anwendungsdatei handelt (Standard: `.go`, konfigurierbar mit der `-e`-Flagge). Wenn das der Fall ist, wird wails automatisch die Anwendung neu builden und neu starten. Wenn sich die geänderte Datei in den Assets befindet, wird nach kurzer Zeit neu geladen.

Der Dev-Server verwendet eine Technik namens "debouncing", was bedeutet, dass er nicht sofort neu geladen wird, da mehrere Dateien in kurzer Zeit geändert werden können. Wenn ein Trigger ausgelöst wird, wartet er eine festgelegte Zeit, bevor er ein Nachladen ausführt. Falls ein anderer Trigger auftritt, wird die Wartezeit erneut gesetzt. Standardmäßig ist dieser Wert `100ms`. Wenn dieser Wert für dein Projekt nicht funktioniert, kann er mit der `-debounce` Flag konfiguriert werden. Wenn verwendet, wird dieser Wert in deiner Projekt-Konfiguration gespeichert und zur Standardeinstellung.

## Externer Dev Server

Einige Frameworks haben ihren eigenen Live-Reloading-Server, aber diese werden nicht in der Lage sein, die Wails Go-Verknüpfungen zu nutzen. In diesem Szenario ist es am besten, ein Watcher-Skript auszuführen, das das Projekt in das Build-Verzeichnis umbaut, welches Wails beobachten wird. Siehe die svelte Standardvorlage, die [rollup](https://rollupjs.org/guide/en/) verwendet.

### Create React App

Der Prozess für ein Create-React-App-Projekt ist etwas komplizierter. Um das Live-Frontend neu laden zu können, muss die folgende Konfiguration zur `wails.json` hinzugefügt werden:

```json
  "frontend:dev:watcher": "yarn start",
  "frontend:dev:serverUrl": "http://localhost:3000",
```

Der `frontend:dev:watcher` Befehl startet den Create-React-App Entwicklungsserver (typischerweise auf Port `3000` gehostet). Der Befehl `frontend:dev:serverUrl` weist Wails dann an, beim Laden des Frontends Assets vom Entwicklungsserver zu verwenden, anstatt aus dem Build-Ordner. Zusätzlich zu den oben genannten Schritten muss die `index.html` mit folgendem aktualisiert werden:

```html
    <head>
        <meta name="wails-options" content="noautoinject" />
        <script src="/wails/ipc.js"></script>
        <script src="/wails/runtime.js"></script>
    </head>
```

Dies wird benötigt, da der Watcher-Befehl, der das Frontend neu aufbaut, Wails daran hindert, die benötigten Skripte zu injizieren. Dies umgeht diese Fehlermeldung, indem sichergestellt wird, dass die Skripte immer injiziert werden. Mit dieser Konfiguration kann `wails dev` ausgeführt werden, wodurch Frontend und Backend mit aktiviertem Hot-Reloading entsprechend erstellt werden. Zusätzlich beim Zugriff auf die Anwendung von einem Browser aus können die React Entwicklerwerkzeuge jetzt auf einer nicht minifizierten Version der Anwendung für einfaches Debuggen verwendet werden. Schließlich kann zur Beschleunigung der Builds `wails dev -s` ausgeführt werden, um den standardmäßigen Build des Frontends durch Wails zu überspringen, da dies ein unnötiger Schritt ist.

## Go Module

Die Standard-Wails Vorlagen erzeugen eine `go.mod` Datei, die den Modulnamen "changeme" enthält. Du solltest dies nach der Projekterstellung in etwas passenderes ändern.
